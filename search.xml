<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows下的包管理工具scoop</title>
    <url>/posts/b4c6dbe7.html</url>
    <content><![CDATA[<p>在Windows系统上，安装软件总是要到官网上去下载安装，又不想使用XX管家类的软件，因此如果有像Linux上的包管理工具就方便了，<em>scoop</em>就是Windows下的包管理工具！</p>
<span id="more"></span>



<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>scoop的安装很简单，官方提供了执行脚本让我们使用了，具体可看官网<a href="https://scoop.sh/">Installs in seconds</a>，步骤大概如下：</p>
<p>安装要求：</p>
<ol>
<li>PowerShell 5 或更高的版本</li>
<li>.NET Framework 4.5 或更高的版本</li>
</ol>
<p>安装命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iwr -useb get.scoop.sh | iex</span><br></pre></td></tr></table></figure>

<p>上面两条命令的效果是一样的。</p>
<p>如果安装时抛出异常，可以尝试如下命令修改执行策略，然后再尝试重新安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned -scope CurrentUser</span><br></pre></td></tr></table></figure>



<h1 id="scoop文件结构"><a href="#scoop文件结构" class="headerlink" title="scoop文件结构"></a>scoop文件结构</h1><p>scoop是安装在当前用户的用户文件夹下的，例如当前用户是test，则在Windows的位置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\test\scoop</span><br></pre></td></tr></table></figure>

<p>scoop根目录下，有如下几个文件夹</p>
<ul>
<li>apps：应用安装区域，所有应用都会安装在这里，每个安装的软件都有一个以自己名字命名的文件夹，内部如下<ul>
<li>以版本命名的文件夹，该文件夹下存放的是指定版本的该软件</li>
<li>current：快捷方式，连接到当前使用的版本</li>
</ul>
</li>
<li>buckets：安装源</li>
<li>cache：下载缓存</li>
<li>persist：应用的配置文件放置地方</li>
<li>shims：映射应用的bin中的文件，集中存放应用命令的链接或调用脚本，自动加入 path 路径中（自动进行兼容性处理），方便命令行的使用，且这样 path 的定义就会比较简洁，也容易管理。</li>
</ul>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><p>安装完成后就可以开始使用了，打开cmd命令行界面输入所需命令即可。</p>
<p>不知道怎么用？使用帮助，即可了解到所有的命令及其用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop help</span><br></pre></td></tr></table></figure>

<p>注：下面以软件potplayer为例</p>
<p>输入关键字搜索想安装的软件，如果能安装则会显示可安装的软件列表，不能则会显示<em>Not Found</em>字眼</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop search potplayer</span><br></pre></td></tr></table></figure>

<p>安装软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop install potplayer</span><br></pre></td></tr></table></figure>

<p>卸载软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop uninstall potplayer</span><br></pre></td></tr></table></figure>

<p>更新软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop update potplayer</span><br></pre></td></tr></table></figure>

<p>更新scoop本身</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop update</span><br></pre></td></tr></table></figure>

<p>查看已安装软件列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop list</span><br></pre></td></tr></table></figure>

<p>查看当前的软件状态（显示当前的版本信息和可更新的版本信息）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop status</span><br></pre></td></tr></table></figure>



<h1 id="添加bucket"><a href="#添加bucket" class="headerlink" title="添加bucket"></a>添加bucket</h1><p>bucket就是我们下载软件的源，查看scoop可以直接识别并添加的bucket</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop bucket known</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示如下</span></span><br><span class="line">main # 默认就有，但收录条件严格，软件较少</span><br><span class="line">extras # 这个最常用，软件最多</span><br><span class="line">versions</span><br><span class="line">nightlies</span><br><span class="line">nirsoft</span><br><span class="line">php</span><br><span class="line">nerd-fonts</span><br><span class="line">nonportable</span><br><span class="line">java</span><br><span class="line">games</span><br><span class="line">jetbrains</span><br></pre></td></tr></table></figure>

<p>添加bucket（这里以extras为例）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop bucket add extras</span><br></pre></td></tr></table></figure>

<p>展示已有的bucket</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop bucket list</span><br></pre></td></tr></table></figure>

<p>移除bucket（这里以extras为例）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop bucket rm extras</span><br></pre></td></tr></table></figure>



<h2 id="添加第三方bucket"><a href="#添加第三方bucket" class="headerlink" title="添加第三方bucket"></a>添加第三方bucket</h2><p>上面添加的bucket是官方认证的，我们也可以添加自己的bucket或者别人制作的bucket，这里是一个按照 Github score（由 Star 数量、Fork 数量和 App 数量综合决定的 Github score）排列的 bucket 列表：<a href="https://github.com/rasa/scoop-directory/blob/master/by-score.md">Scoop buckets by Github score</a>。对于第三方的操作稍微有些不一样：</p>
<p>添加第三方的bucket</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop bucket add &lt;仓库名&gt; &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure>

<p>安装第三方bucket的应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop install &lt;仓库名&gt;/&lt;应用名&gt;</span><br></pre></td></tr></table></figure>

<p>安装应用前，可以用关键词“应用名+scoop”搜索一下，看看存不存在对应的bucket。</p>
<p>注：如果动手能力强的可以自己制作bucket。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>scoop允许我们对其进行配置，而我遇到过需要配置的就只有设置代理和aria2下载加速。</p>
<p>设置配置方式如下，如果多次设置则以最新的为准</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop config 配置名 配置值</span><br></pre></td></tr></table></figure>

<p>查看已设置的配置（这里只能一个一个查看，没有列出所有的方法）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop config 配置名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果设置了的话会显示配置的值</span></span><br><span class="line">配置值</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有设置的话会显示如下信息</span></span><br><span class="line">配置名 is not set</span><br></pre></td></tr></table></figure>

<p>移除配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop config rm 配置名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功移除显示如下信息</span></span><br><span class="line">配置名 has been removed</span><br></pre></td></tr></table></figure>



<h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>有时候在国内下载速度慢，可以通过设置代理来提高下载速度。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop config proxy &#x27;127.0.0.1:8080&#x27;</span><br></pre></td></tr></table></figure>

<p>这里只列举了我知道的方式，还有其它的设置代理方式<a href="https://github.com/lukesampson/scoop/wiki/Using-Scoop-behind-a-proxy">Configuring Scoop to use your proxy</a></p>
<h1 id="配置aria2下载加速"><a href="#配置aria2下载加速" class="headerlink" title="配置aria2下载加速"></a>配置aria2下载加速</h1><p>单纯的使用scoop下载速度可能不够快，这时候可以用scoop下载aria2来进一步提高下载速度，scoop会自动调用下载的aria2（注：一定要用scoop安装）</p>
<p>安装aria2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop install aria2</span><br></pre></td></tr></table></figure>

<p>本身有默认参数值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aria2-enabled (default: true) # 是否使用aria2加速下载，开启true，关闭false</span><br><span class="line">aria2-retry-wait (default: 2)</span><br><span class="line">aria2-split (default: 5)</span><br><span class="line">aria2-max-connection-per-server (default: 5) # 同时下载的线程数</span><br><span class="line">aria2-min-split-size (default: 5M)</span><br></pre></td></tr></table></figure>

<p>也可以自己进行参数设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop config aria2-max-connection-per-server 16</span><br><span class="line">scoop config aria2-split 16</span><br><span class="line">scoop config aria2-min-split-size 1M</span><br></pre></td></tr></table></figure>

<p>具体的参考<a href="https://scoop-docs.now.sh/docs/misc/Multi-connection-downloads-with-aria2.html">Multi-connection downloads with <code>aria2</code></a></p>
<h1 id="设置不同的开发环境版本"><a href="#设置不同的开发环境版本" class="headerlink" title="设置不同的开发环境版本"></a>设置不同的开发环境版本</h1><p>做程序开发的对于同一个开发环境可能需要安装不同的版本，例如：Java8和Java11、python2和python3，如果由自己做环境控制，就很麻烦了，通过scoop可以轻易的进行切换</p>
<p>假设我安装了jdk8和jdk11</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面显示的是已安装的软件列表</span></span><br><span class="line">......</span><br><span class="line">openjdk11 11.0.2-9 </span><br><span class="line">openjdk8-redhat 8u282-b08</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>切换至jdk8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop reset openjdk8-redhat</span><br></pre></td></tr></table></figure>

<p>切换至jdk11</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop reset openjdk11</span><br></pre></td></tr></table></figure>



<h1 id="批量导入和导出"><a href="#批量导入和导出" class="headerlink" title="批量导入和导出"></a>批量导入和导出</h1><p>scoop安装了一系列软件后，换台设备还想继续使用这些软件，但是一个一个手动安装的话就太麻烦了，对于这方面scoop没有提供原生的支持，但是也有额外的方式能实现该要求：</p>
<p><a href="https://github.com/lukesampson/scoop/issues/1543#issuecomment-308894312">方式一：通过记录应用列表来实现</a></p>
<p><a href="%5BScoopBackup-pwsh%5D(https://github.com/Cologler/ScoopBackup-pwsh)">方式二：使用备份工具</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>scoop</category>
      </categories>
      <tags>
        <tag>scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks安装指南</title>
    <url>/posts/ee1d977a.html</url>
    <content><![CDATA[<p>有时候想访问国外的网站，但是却访问不了，这时候就需要使用代理访问的方式进行访问。<em>shadowsocks</em>就是能提供这么一种服务的工具。</p>
<span id="more"></span>

<h1 id="shadowsocks服务"><a href="#shadowsocks服务" class="headerlink" title="shadowsocks服务"></a>shadowsocks服务</h1><p>要使用shadowsocks，首先需要一台安装了shadowsokcs服务的服务器，有两种获得方法：</p>
<ul>
<li>购买别人的shadowsokcs服务</li>
<li>自建shadowsokcs服务</li>
</ul>
<p>第一种很好理解，就是花钱买服务，优点是省心而且有多个服务器进行网速优化，但是缺点也很明显：价格偏高、市场上提供的服务质量参差不齐，且容易跑路（建议一个月一个月的买），这部分博主不太熟悉，只能读者们自己去搜索相关信息了，在这里主要说的第二种方法。</p>
<p>要自建shadowsocks服务，先要有一台服务器，需要注意的是这台服务器一定要在国外的，起码要在香港、澳门这些地方，因为一般来说使用shadowsocks主要是访问国内无法访问的网站，所以如果服务器在国内的话就无法访问了。</p>
<h1 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h1><p>shadowsokcs最开始是使用python进行开发的，后续有许多贡献者开发出了不同的版本，我见过的版本如下：</p>
<ul>
<li>shadowsocks-libev：c语言开发，内存占用少，没有多用户管理的功能，其它更多的功能不清楚，我一直用的是这个版本。</li>
<li>shadowsocks-python：python语言开发，应该是最初的版本一直开发下来，能进行多用户管理。</li>
<li>shadowsocks-go：go语言开发，这个没用过，请自行搜索。</li>
</ul>
<h1 id="一键安装脚本"><a href="#一键安装脚本" class="headerlink" title="一键安装脚本"></a>一键安装脚本</h1><p>安装shadowsocks-libev版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh</span><br><span class="line">chmod +x shadowsocks-libev.sh</span><br><span class="line">./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log</span><br></pre></td></tr></table></figure>

<p>多语言合一版（包含：libev、python、go）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>shadowsocks</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>博客之2019</title>
    <url>/posts/87daa986.html</url>
    <content><![CDATA[<p>2019年的第三个月即将过去了，现在才写这篇文章好像迟了一点，不过种一棵树最好的时间是十年前，其次是现在，这样子安慰自己的话，好像还不算晚。</p>
<p>在2018年里仅仅写了几篇文章，不过幸运的是因为有个博客，所以总想着弄点什么来写写，从而养成了写文档的习惯，遇到不懂的、特别的都有记录下来，期望在后面的时间里写到博客上。</p>
<p>在前段时间，突然萌生了换个博客的想法，wordpress、typecho、hugo这些都研究了一圈，感觉就像换了一个博客所有的事情都将变得会不一样似的，就像2018年里的目标并没有达成，反而是东学学西学学但并没有实质性的进展。</p>
<p>最后的最后，其实自己需要的是一点坚持——对目标的坚持，也是对适合自己的学习方法的一个概括：坚持！每天运动一下、学习一下、记录一下，明天就会有那么一点不一样！</p>
<p>题外话：最后还是没忍住折腾劲，对博客进行了修改，当然博客程序还是那个，但是配置上做了很多修改，对以前的文章的结构、分类、命名、内容这些也不大满意，所以也进行了修改。</p>
]]></content>
      <categories>
        <category>博客日志</category>
      </categories>
      <tags>
        <tag>博客日志</tag>
      </tags>
  </entry>
  <entry>
    <title>博客之始</title>
    <url>/posts/40124174.html</url>
    <content><![CDATA[<p>以前总是看别人写的博客，用OneNote做的笔记，当面试的时候被问到：你有写博客吗？我的回答是NO！  那时候以为写博客离自己很遥远，觉得自己的水平低写不出什么东西来，但是现在仔细想想，不正是因为自己的水平低才更要写博客吗！</p>
<p>通过写博客来做笔记并且加入自己的思考，摆脱以前一贯的只记忆不思考的习惯，一次又一次地修改完善，才能更好的提高自己的能力。</p>
<p>在这特殊的一天，踏出新的一步，祝2018年大家越来越好！</p>
]]></content>
      <categories>
        <category>博客日志</category>
      </categories>
      <tags>
        <tag>博客日志</tag>
      </tags>
  </entry>
  <entry>
    <title>docker服务及其容器自启动</title>
    <url>/posts/f31ac7c3.html</url>
    <content><![CDATA[<p>服务器重启后docker服务和容器都会停止运行，如果每次都手动启动的话就很繁琐了，因此配置为自启动就很有必要了。</p>
<span id="more"></span>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>服务器系统：centos7</p>
<p>docker 版本：19.03.5</p>
<h1 id="docker服务自启动"><a href="#docker服务自启动" class="headerlink" title="docker服务自启动"></a>docker服务自启动</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启自启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭自启动</span></span><br><span class="line">systemctl disable docker</span><br></pre></td></tr></table></figure>

<p>PS：systemctl就是直接操作系统服务，是service、chkconfig命令的组合，如果没有systemctl命令，请自行搜索其它方案。</p>
<h1 id="docker容器自启动"><a href="#docker容器自启动" class="headerlink" title="docker容器自启动"></a>docker容器自启动</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建容器前加入参数--restart</span></span><br><span class="line">docker run --restart=参数项</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 已创建容器则使用如下命令</span></span><br><span class="line">docker update --restart=参数项 [容器名]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --restart参数解析</span></span><br><span class="line">no：不要自动重启容器（默认）</span><br><span class="line">on-failure：如果容器由于非正常退出（非零退出代码）而停止运行则重新启动容器，可以加入重启次数，如--restart=on-failure:3 即尝试3次后不再重新启动</span><br><span class="line">always：总是重启容器，如果是手动停止，则仅在docker服务重启或重新手动启动该容器时才重新启动</span><br><span class="line">unless-stopped：总是重启容器，但是如果容器是已经停止了（手动停止或其他方式），即使docker服务重新启动也不会重新启动容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line">docker update --restart=on-failure [容器名]</span><br><span class="line">docker update --restart=on-failure:3 [容器名]</span><br><span class="line">docker update --restart=always [容器名]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务的启动</title>
    <url>/posts/ce090114.html</url>
    <content><![CDATA[<p>由于项目由单体变成了微服务的形式，因此项目的启动由一次变成了多次，但是单体项目与微服务有个不同点，就是微服务的服务之间存在依赖关系，不当的启动顺序会导致服务启动失败。</p>
<span id="more"></span>

<p>PS：以下仅作记录，没有真实使用过。</p>
<p>按照依赖顺序依次启动服务，但是微服务架构的项目，单个服务的实例的次数都不止一个，更不要说整个项目了，手动启动的话肯定是不允许的。</p>
<h1 id="wait-for-it-sh和服务健康检查"><a href="#wait-for-it-sh和服务健康检查" class="headerlink" title="wait-for-it.sh和服务健康检查"></a>wait-for-it.sh和服务健康检查</h1><p>为了便于微服务的分发和管理，使用Docker打包然后分发是一个很好的实践。</p>
<p>对于微服务间的服务依赖，Docker官方给出的建议是：通过wait-for-it.sh脚本来控制，即通过脚本探测某个依赖的服务的tcp端口是否开放，否则一直等待，直到端口探测成功，才会启动后面的命令；也可以通过服务健康检查来实现。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.docker.com/compose/startup-order/">https://docs.docker.com/compose/startup-order/</a></p>
<p><a href="https://stackoverflow.com/questions/48684609/control-startup-order-in-docker-compose">https://stackoverflow.com/questions/48684609/control-startup-order-in-docker-compose</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/posts/dfdb52be.html</url>
    <content><![CDATA[<p>AQS即同步器，用于构建锁和同步器的抽象类，使用AQS能简单且高效地构建出应用广泛的大量的同步器。</p>
<span id="more"></span>



<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>AQS核心思想：如果被请求的共享资源空闲，则把当前请求的线程设置为有效的线程，并且把共享资源的状态设置为锁定。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<h2 id="关键成员变量state"><a href="#关键成员变量state" class="headerlink" title="关键成员变量state"></a>关键成员变量state</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>AQS通过volatile int成员变量<strong>state</strong>来标识同步状态，使用CAS对该同步状态进行原子操作实现值的修改。通过FIFO队列来完成获取资源线程的排队工作</p>
<h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>CLH（Craig,Landin,and Hagersten）队列是一个虚拟的双向队列，即不存在队列实例，仅存在节点间的关联关系。AQS把每条请求共享资源的线程封装成一个CLH锁队列的一个节点来实现锁的分配。</p>
<h1 id="独占和共享"><a href="#独占和共享" class="headerlink" title="独占和共享"></a>独占和共享</h1><p>AQS定义了两种资源共享的方式：独占（只有一个线程能够执行）、共享（多个线程可以同时执行）。</p>
<p>独占可以分为公平锁和非公平锁</p>
<ul>
<li>公平锁：按照线程在队列中的顺序，先到者先拿到锁；</li>
<li>非公平锁：无视队列顺序，谁抢到就是谁的。</li>
</ul>
<h2 id="两对方法"><a href="#两对方法" class="headerlink" title="两对方法"></a>两对方法</h2><p>使用AQS实现自己的锁，依据资源的共享方式，需要实现不同的方法。</p>
<p>资源共享的方式为<strong>独占</strong>，则需要实现的方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tryAcquire(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>尝试获取资源，成功则返回true，失败则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tryRelease(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>尝试释放资源，成功则返回true，失败则返回false。</p>
<p>资源共享的方式为<strong>共享</strong>，需要实现的方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tryAcquireShared(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tryReleaseShared(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>尝试释放资源，成功则返回true，失败则返回false。</p>
<p>*<em>总结：独占模式下主要实现：</em>tryAcquire()<em>和</em>tryRelease()<em>方法，共享模式下主要实现</em>tryAcquireAndShared()<em>和</em>tryReleaseShared()<em>方法，这些方法一般都是成对使用，但也有同时实现使用情形，例如：ReentrantReadWriteLock。</em>*</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基本数据类型</title>
    <url>/posts/c80e1ec8.html</url>
    <content><![CDATA[<p>要用Java必然绕不开它的基本数据类型，</p>
<span id="more"></span>



<h1 id="8种基本数据类型"><a href="#8种基本数据类型" class="headerlink" title="8种基本数据类型"></a>8种基本数据类型</h1><p>Java的基本数据类型分为数值型、布尔值和字符三个大类，共计8种基本数据类型：byte、short、int、long、float、double、boolean、char。</p>
<p><img src="/images/Java%E7%9A%848%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="Java的8种基本数据类型"></p>
<p>基本数据类型对应的位数、字节和默认值如下</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>8</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
<td>0f</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>8</td>
<td>0d</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>2</td>
<td>u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td></td>
<td>false</td>
</tr>
</tbody></table>
<p>注：对于boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用名词</title>
    <url>/posts/b0269417.html</url>
    <content><![CDATA[<p>接触Java开发已经很长一段时间了，对于常见的名词，如：JMS、JDBC、JPA，也基本知道代表的是什么，而JNDI、JTA这些就不知道了，今天特意做个备忘录，记录下在Java中遇到的这些名词，并在后续中不断更新。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">名词</th>
<th align="center">全称</th>
<th align="center">中文</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDBC</td>
<td align="center">Java DataBase Connectivity</td>
<td align="center">Java数据库连接</td>
</tr>
<tr>
<td align="center">JPA</td>
<td align="center">Java Persistence API</td>
<td align="center">Java持久化API</td>
</tr>
<tr>
<td align="center">JTA</td>
<td align="center">Java Transaction API</td>
<td align="center">Java事务API</td>
</tr>
<tr>
<td align="center">JMS</td>
<td align="center">Java Message Service</td>
<td align="center">Java消息服务</td>
</tr>
<tr>
<td align="center">JNDI</td>
<td align="center">Java Naming and Directory Interface</td>
<td align="center">Java命名和目录接口</td>
</tr>
<tr>
<td align="center">POJO</td>
<td align="center">Plain Ordinary Java Object</td>
<td align="center">简单Java对象</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的foreach</title>
    <url>/posts/4c0b6fc5.html</url>
    <content><![CDATA[<p>开发中经常使用到foreach，现在是时候深入了解一下了。</p>
<span id="more"></span>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>foreach是for的增强，基本语法结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的collection 指数组或集合</span></span><br><span class="line"><span class="keyword">for</span>(T t : collection) &#123;</span><br><span class="line">  ... dosomething ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 集合</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(String str : list) &#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>由上面的例子可以看到，在写法上foreach与for写法相比是简化了很多。</p>
<p>要注意的一点是：使用foreach能遍历的，使用for也能遍历，反之则不一定能！！！</p>
<p>其次还有一些缺点：</p>
<ul>
<li>对于数组，在遍历过程中需要使用元素下标的，则无能为力。</li>
<li>对于集合，在遍历过程中无法对元素进行增删，否则会报异常，因为我们没法获得迭代器进行操作。</li>
</ul>
<h1 id="遍历的顺序"><a href="#遍历的顺序" class="headerlink" title="遍历的顺序"></a>遍历的顺序</h1><p>有时候我们可能对元素的遍历顺序有要求，那么使用foreach与for的遍历顺序是一致的吗？</p>
<p>答案是一样的！！</p>
<p>通过阅读官方的文档可以知道，对数组使用foreach写法，等同于下面的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于集合而言，就和使用迭代器进行遍历一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator iterator = collection.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">  iterator.next <span class="keyword">do</span> something......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h1><p>对于集合而言，使用foreach的遍历，其实就是在使用迭代器进行遍历，这点通过Java的规范文档可以了解到，也可以通过对Java的class文件反编译观察到，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/e6dffef4gy1gaqphag66lj21bb0bqtjk.jpg" alt="foreach与迭代器.png"></p>
<p>但是与直接使用iterator不同，使用foreach的过程中，是无法对元素进行增删的，因为iterator是隐含的仅存在于编译后的class文件中，即开发中无法直接获取iterator，因而也就无法执行增删操作。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/81cec83541be">Java中的foreach遍历顺序</a></p>
<p><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.14.2">Java规范文档-看14.14.2. The enhanced for statement部分</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Map的N种遍历方法</title>
    <url>/posts/35b60266.html</url>
    <content><![CDATA[<p>开发中经常要使用到集合类Map，现在让我们来研究一下究竟有多少种遍历方法吧。</p>
<span id="more"></span>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>遍历map时，我们想获得啥？</p>
<p>键值对？键？值？</p>
<p>贴心的Java已经定义了如下的三种方法供我们使用：</p>
<ul>
<li>entrySet()：获取键值对集合，返回类型是Set</li>
<li>keySet()：获取键集合，返回类型是Set</li>
<li>values()：获取值集合，返回类型是Collection</li>
</ul>
<p>由上面的返回类型可以知道，我们要遍历map，其实就是要遍历Collection，常用的遍历Collection方法：</p>
<ul>
<li>增强型for</li>
<li>迭代器</li>
<li>Lambda</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;firstElement&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;secondElement&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for遍历</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;for-entry 键：&quot;</span> + entry.getKey() + <span class="string">&quot;, 值：&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String k : map.keySet()) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;for-key 键：&quot;</span> + k + <span class="string">&quot;, 值：&quot;</span> + map.get(k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer v : map.values()) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;for-value 值：&quot;</span> + v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">  System.out.println(<span class="string">&quot;iterator-entry 键：&quot;</span> + entry.getKey() + <span class="string">&quot;, 值：&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; kIterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (kIterator.hasNext()) &#123;</span><br><span class="line">  String key = kIterator.next();</span><br><span class="line">  System.out.println(<span class="string">&quot;iterator-key 键：&quot;</span> + key + <span class="string">&quot;, 值：&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; vIterator = map.values().iterator();</span><br><span class="line"><span class="keyword">while</span> (vIterator.hasNext()) &#123;</span><br><span class="line">  Integer value = vIterator.next();</span><br><span class="line">  System.out.println(<span class="string">&quot;iterator-value 值：&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda</span></span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Lambda-entry 键：&quot;</span> + k + <span class="string">&quot;, 值：&quot;</span> + v);</span><br><span class="line">&#125;);</span><br><span class="line">map.entrySet().forEach(entry -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Lambda-entry 键：&quot;</span> + entry.getKey() + <span class="string">&quot;, 值：&quot;</span> + entry.getValue());</span><br><span class="line">&#125;);</span><br><span class="line">map.keySet().forEach(key -&gt; System.out.println(<span class="string">&quot;Lambda-key 键：&quot;</span> + key + <span class="string">&quot;, 值：&quot;</span> + map.get(key)));</span><br><span class="line">map.values().forEach(value -&gt; System.out.println(<span class="string">&quot;Lambda-value 值：&quot;</span> + value));</span><br></pre></td></tr></table></figure>

<h1 id="entrySet-、keySet-和values-的作用"><a href="#entrySet-、keySet-和values-的作用" class="headerlink" title="entrySet()、keySet()和values()的作用"></a>entrySet()、keySet()和values()的作用</h1><p>就像我们会遍历Collection集合一样，偶尔我们也会因业务需求遍历Map，但是Map的实现并不像Collection这么简单，底层是个数组或者链表什么的。</p>
<p>以HashMap为例，它的底层数据结构是：数组+链表+红黑树，这样作为开发者的我们就要花费大量精力去实现怎么遍历。</p>
<p>因此特意提供了entrySet()、keySet()和values()这三个方法，屏蔽底层的实现，提供简单易用的Collection。</p>
<h1 id="3种遍历方法的本质"><a href="#3种遍历方法的本质" class="headerlink" title="3种遍历方法的本质"></a>3种遍历方法的本质</h1><blockquote>
<p>迭代器模式：<strong>提供一种方法顺序的访问一个聚合对象中各个元素，而又不暴露该对象的内部表示</strong>。</p>
</blockquote>
<p>虽然上面提供了三种遍历方式，但其本质依然调用了迭代器：</p>
<ul>
<li>增强型for循环，其底层是使用了iterator，这点可以通过编译后的代码可以了解到。</li>
<li>使用了Lambda表达式的forEach，其方法体内部依然是使用了增强型for循环。</li>
</ul>
<p>通过使用迭代器我们就能轻易的访问集合对象而又无须关注集合对象的内部实现。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String、StringBuilder和StringBuffer</title>
    <url>/posts/2871eb40.html</url>
    <content><![CDATA[<p>String是Java中使用频率极高的一个类，但由于其是不可变，因此有StringBuffer和StringBuilder两个类来弥补在大量修改场景下的不足。</p>
<span id="more"></span>



<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>当我们需要存储单一的字符时，使用的是基本数据类型<em>char</em>来进行存储，而要存储一连串的字符时，毫无疑问的是想到使用字符数组*char[]*来进行存储，如果代码中每次都要先声明数组才能存储字符串就显得非常冗余和烦琐了，因此贴心的Java为我们提供了String类。</p>
<p>String类的数据结构如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>

<p>可以看到String类确实就是用一个字符数组来存储字符串的，但这是Java版本1.9版本之前的内容。</p>
<h2 id="数据类型的改变"><a href="#数据类型的改变" class="headerlink" title="数据类型的改变"></a>数据类型的改变</h2><p>在Java版本1.9之后，String类的数组的数据类型就由<em>char[]<em>改为了</em>byte[]</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br></pre></td></tr></table></figure>

<p>博主由于对这个变化了解的不是很透彻，因此摘抄了别人的解释，具体可看<a href="https://github.com/Snailclimb/JavaGuide/issues/675">这里</a>或者自行搜索相关内容。</p>
<blockquote>
<p>为什么使用byte字节而舍弃了char字符:</p>
</blockquote>
<blockquote>
<p>节省内存占用，byte占一个字节(8位)，char占用2个字节（16），相较char节省一半的内存空间。节省gc压力。<br>针对初始化的字符，对字符长度进行判断选择不同的编码方式。如果是 LATIN-1 编码，则右移0位，数组长度即为字符串长度。而如果是 UTF16 编码，则右移1位，数组长度的二分之一为字符串长度。</p>
</blockquote>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>String类的不可变性是由几个方面实现</p>
<ol>
<li><p>String类本身由final修饰符进行修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure></li>
<li><p>存储字符的属性值value由private修饰符修饰，且没有提供<em>setter</em>方法供外界进行修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br></pre></td></tr></table></figure></li>
<li><p>虽然存储字符的属性值value使用了final修饰符进行修饰，但是仅能做到变量value对于数组的引用不变而已，而无法阻止数组元素的修改，<strong>通过查看String的源码其实可以发现，Java的开发者很小心的处理String类中的每一行代码，从而做到在细节上实现了不可变（即没有修改数组元素）</strong></p>
</li>
</ol>
<p>通过以上的几个方面，实现了String类无法被继承且内部元素无法被修改，做到了String的不可变，由于其不可变性，可以理解为一个常量，因此<strong>String类是线程安全的</strong>。</p>
<p>注：如果真的要破坏String类的不可变性，只能通过使用反射的方式进行破坏，强行进行修改了。</p>
<h1 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h1><p>由于String类的不可变性，每一次修改为不同的字符串就会生成一个新的String对象，这明显不利于在需要大量修改字符串内容的场景，因此Java提供了StringBuilder类和StringBuffer类来实现字符串的动态修改，只有在最后修改完毕后才才调用*toString()*方法真正的生成String对象。</p>
<h2 id="抽象类AbstractStringBuilder"><a href="#抽象类AbstractStringBuilder" class="headerlink" title="抽象类AbstractStringBuilder"></a>抽象类AbstractStringBuilder</h2><p>StringBuilder类和StringBuffer类都是继承自<em>抽象类AbstractStringBuilder</em>，部分代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] value;</span><br></pre></td></tr></table></figure>

<p>可以看到注释，属性value就是存储字符串的地方，且没有使用final修饰符进行修饰，因此是可变的。</p>
<p><em>AbstractStringBuilder</em>类本身提供且实现了大量的修改字符串内容的方法，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法，StringBuffer类和StringBuilder类的许多方法实现上都是直接调用的父类（AbstractStringBuilder）的方法。</p>
<h2 id="线程安全和性能"><a href="#线程安全和性能" class="headerlink" title="线程安全和性能"></a>线程安全和性能</h2><p>虽说StringBuilder类和StringBuffer类都是继承自<em>抽象类AbstractStringBuilder</em>，整体上都是差不多，但是在性能和多线程操作处理上存在区别</p>
<ul>
<li><p>线程安全</p>
<p>StringBuilder类并没有对方法做任何多线程方面的处理，因此是非线程安全的。</p>
<p>StringBuffer类中大量的使用<strong>synchronized</strong>关键字对方法进行了加锁操作，因此是线程安全的。</p>
</li>
<li><p>性能</p>
<p>StringBuffer类由于其方法上的加锁操作，因此性能要比StringBuilder类低。</p>
</li>
</ul>
<p><strong>总结：需要考虑线程安全的就用StringBuffer，无线程安全问题且重视性能的就用StringBuilder，无脑操作就选StringBuffer。</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/cd72099051f9">String类的不可变性</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/675">Java 9 之后，String 类的实现改用 byte 数组存储字符串</a></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>wait()和sleep()方法的区别</title>
    <url>/posts/9a65c93a.html</url>
    <content><![CDATA[<p>多线程开发中，让线程暂停执行是常见场景，Java提供了*sleep()<em>和</em>wait()*两种实现方法，但在具体使用上又有稍微差别。</p>
<span id="more"></span>



<h1 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h1><ul>
<li>相同点：*sleep()<em>和</em>wait()*的作用都是暂停线程的执行，进入阻塞状态，让出CPU时间片段。</li>
<li>区别<ul>
<li>锁资源的释放：*sleep()<em>方法调用后线程不会释放锁资源；</em>wait()*方法调用后线程会释放锁资源。</li>
<li>使用场景：*sleep()<em>仅用于线程暂停执行；</em>wait()*通常用于线程间交互或通信；</li>
<li>线程唤醒：*sleep()*调用后线程会自动唤醒（由系统调度器唤醒，时间到了被调度）；wait()调用后，线程不会自动唤醒(需要其它线程使用同一个对象上的notify()或者notifyAll()方法唤醒)，也可以使用带有超时设置的wait()方法超时后自动唤醒。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程和线程池的关闭</title>
    <url>/posts/c6b69b48.html</url>
    <content><![CDATA[<p>为了最大限度的提高系统性能，线程和线程池的使用都是必不可少的，使用后往往面临一个相同的问题：关闭！</p>
<span id="more"></span>



<h1 id="线程的关闭"><a href="#线程的关闭" class="headerlink" title="线程的关闭"></a>线程的关闭</h1><p>由于不知道线程的运行状态，因此在运行途中直接关闭一个线程是非常危险的操作，JDK文档上就有这样一个例子：假如线程获取了某把锁，然后强制关闭了，会导致锁资源无法被释放的严重后果。因此Thread类上的<em>stop()<em>方法在Java版本1.2就</em>不推荐使用</em>了。</p>
<p>运行途中线程何时能关闭，只有线程自己知道，开发者能做的就是调用中断方法*interrupt()*通知线程关闭。</p>
<p>调用*interrupt()*方法，在不同的场景下会有不同的效果（版本：Java11）</p>
<ul>
<li><p>被<em>Object类的wait()、wait(long)、wait(long, int)方法</em>或者<em>Thread类的join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)方法</em>调用而阻塞的线程，将会<strong>清除中断状态</strong>，同时<strong>抛出异常InterruptedException</strong></p>
</li>
<li><p>对于被IO阻塞的线程</p>
<ul>
<li>如果是被NIO中的channel操作而阻塞的，将会<strong>设置中断状态</strong>，同时<strong>抛出异常ClosedByInterruptException</strong></li>
<li>如果是被NIO中的Selectorl操作而阻塞的，只会<strong>设置中断状态</strong></li>
</ul>
</li>
<li><p>不符合以上条件的，就直接<strong>设置中断状态</strong></p>
</li>
<li><p>对于还没启动的线程或者线程已被销毁的，调用*interrupt()*方法是<strong>没有任何效果</strong>的</p>
</li>
</ul>
<p>调用*interrupt()<em>方法后，如果抛出异常，我们就可以通过捕获异常来让线程正常退出了，如果没有抛出异常仅是设置了中断状态，就要依靠线程中的代码逻辑来判断了，在代码中的适当位置调用</em>isInterrupted()*来查看自己是否被中断，进而让线程正常退出。</p>
<p>要注意的是：线程先调用*interrupt()*方法再被阻塞的话，就会抛出异常，但是捕获异常后再被阻塞的话，将不会再次抛出异常。</p>
<p>Thread类还有一些其它类似的方法：</p>
<ul>
<li>isInterrupted()方法：测试当前线程是否被中断，但是不会修改中断状态。</li>
<li>interrupted()方法：测试当前线程是否被中断，但是会清除中断状态，即原本是设置了中断状态的线程，调用该方法后，会变成没有将中断。</li>
<li>isAlive()方法：测试当前线程是否存在（存在指的是：线程已启动且还没被销毁）。</li>
<li>Thread.interrupted()静态方法：与*interrupted()*方法的效果一样，但是实现方式不同。</li>
</ul>
<h1 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h1><p>线程池提供了两个关闭线程池的方法：**shutdownNow()<strong>和</strong>shutdown()**。</p>
<ul>
<li><p>shutdownNow方法：尝试停止正在执行的任务，暂停等待任务的处理，并返回正在等待执行的任务列表，这个方法不保证能停止正在执行的任务。</p>
</li>
<li><p>shutdown方法：依次关闭之前提交执行的任务，并且拒绝接收新的任务，如果线程池已关闭但又调用了该方法将不会有任何影响。</p>
</li>
</ul>
<p>调用**shutdownNow()<strong>或</strong>shutdown()*<em>方法后，线程池并不是立刻关闭的，要想等待线程池关闭，需要调用</em>awaitTermination()*方法来阻塞等待。</p>
<h2 id="简单的源码分析"><a href="#简单的源码分析" class="headerlink" title="简单的源码分析"></a>简单的源码分析</h2><p>shutdownNow()关键源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">advanceRunState(STOP);</span><br><span class="line">interruptWorkers();</span><br><span class="line">tasks = drainQueue();</span><br></pre></td></tr></table></figure>

<p>第一段是设置线程池的状态为停止，第二段是遍历工作队列调用线程的调用*interrupt()*方法，第三段是返回任务队列。</p>
<p>shutdown()关键源码是类似的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">advanceRunState(SHUTDOWN);</span><br><span class="line">interruptIdleWorkers();</span><br></pre></td></tr></table></figure>

<p>第一段是设置线程池的状态为关闭，第二段是遍历工作队列调用线程的调用*interrupt()*方法。</p>
<p><em>注意：上述源码分析非常粗浅，请自行查阅相关资料。</em></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作指南：01-新建用户</title>
    <url>/posts/1eb05570.html</url>
    <content><![CDATA[<p>在Linux上root用户拥有最高的权限，但是多人共享root账户或者直接使用root账户都是一件危险的事情，因此新建普通用户给其它操作员是一件顺理成章的事情。</p>
<span id="more"></span>

<p><strong>注：演示使用的Linux操作系统是Centos 7</strong></p>
<h1 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h1><h2 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h2><p>全新的Linux系统默认都是只有root账户，因此通过root用户来创建用户，当然也可以使用具备新建用户的权限的用户来创建用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd test</span><br></pre></td></tr></table></figure>

<p>此时通过查看命令即可看到home目录下多了个test目录，即代表用户test已经成功创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -l 查看命令</span></span><br><span class="line">ls -l /home</span><br><span class="line">drwx------  2 test   test   4096 Jan 10 21:32 test</span><br></pre></td></tr></table></figure>

<h1 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h1><p>使用<em>useradd</em>命令创建用户后，此时由于没有设置密码，该新建的账户是无法登陆使用的，因此需要给该新账户添加密码（注：修改密码使用的是同一个命令）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> passwd 修改密码命令</span></span><br><span class="line">passwd test</span><br><span class="line">New password: </span><br></pre></td></tr></table></figure>

<p>此时即可输入新密码了，但是会发现好像一直按键盘都是空的，这就是Linux的安全策略，光给密码打码还不够安全，连长度都不知道才是真的安全，输入完密码按回车键即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd test</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br></pre></td></tr></table></figure>

<p>输入完第一次后还会要求你再重复输入一次，以防你输入错误的密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd test</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>

<p>两次输入密码成功后会出现成功的提示信息，此时新建账户已经可以使用了。</p>
<p>但是有时候可不是这么顺利，比如说输入的密码太短：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd test</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br></pre></td></tr></table></figure>

<p>或者输入的密码中包含用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd test</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD: The password contains the user name in some form</span><br></pre></td></tr></table></figure>

<p>又或者输入的密码太简单</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd test</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD: The password fails the dictionary check - it is too simplistic/systematic</span><br></pre></td></tr></table></figure>

<p>以上的几种情况都会导致输入的密码无效，要重新输入新的密码。</p>
<h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>新建的用户在使用一段时间后可能会面临删账户的情况，使用如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel test</span><br></pre></td></tr></table></figure>

<p>但是这样只是仅仅删除了账户，而home目录下的账户目录是没有被删除的，因此可以选择加入参数*-R*在删除账户的同时删除对应的用户目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel -R test</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是在Linux中关于账户的一些常用操作。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作指南：02-配置防火墙端口</title>
    <url>/posts/c62f803c.html</url>
    <content><![CDATA[<p>新装的Linux系统，ssh、nginx、tomcat等各种服务都安装好了，可是在外网却访问不了？？这十有八九是防火墙的端口没有打开了。</p>
<span id="more"></span>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统：CentOS 7</p>
<h1 id="firewall-cmd与iptables"><a href="#firewall-cmd与iptables" class="headerlink" title="firewall-cmd与iptables"></a>firewall-cmd与iptables</h1><p>到了CentOS 7，防火墙的操作命令由<em>iptables</em>改为了<em>firewall-cmd</em>了。以下是摘抄自<a href="https://wangchujiang.com/linux-command/c/firewall-cmd.html">他人</a>的解释：</p>
<blockquote>
<p>firewall-cmd 是 firewalld的字符界面管理工具，firewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念。</p>
<p>firewalld跟iptables比起来至少有两大好处：</p>
<ol>
<li>firewalld可以动态修改单条规则，而不需要像iptables那样，在修改了规则后必须得全部刷新才可以生效。</li>
<li>firewalld在使用上要比iptables人性化很多，即使不明白“五张表五条链”而且对TCP/IP协议也不理解也可以实现大部分功能。</li>
</ol>
<p>firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现，也就是说firewalld和 iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结 构以及使用方法不一样罢了。</p>
</blockquote>
<p>总的来说这次变更带来的直观好处就是变的更方便更好用了。</p>
<h1 id="端口开发的两种方式"><a href="#端口开发的两种方式" class="headerlink" title="端口开发的两种方式"></a>端口开发的两种方式</h1><p>开放端口有两种方式：指定端口和指定服务。</p>
<p>指定端口很好理解，就是写上那个端口号就开放那个端口。</p>
<p>指定服务可以理解为内置的一个端口映射，默认情况下：ssh服务端口是22、http服务端口是80、MySQL服务端口是3306、tomcat服务端口是8080，因此用服务名来代替直接指定端口，方便记忆和使用。</p>
<p><strong>要注意的是：通过指定服务名开放的就要通过指定服务名关闭；通过指定端口号开放的就要通过指定端口号关闭，且指定端口的时候一定要指定是什么协议，tcp 还是 udp。</strong></p>
<h1 id="permanent参数和zone参数"><a href="#permanent参数和zone参数" class="headerlink" title="permanent参数和zone参数"></a>permanent参数和zone参数</h1><p>配置端口的时候这两个参数是会经常使用到的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent</span><br></pre></td></tr></table></figure>

<p>这个很好理解，就是让配置永久生效的意思。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public</span><br></pre></td></tr></table></figure>

<p><strong>zone</strong>参数就难以理解一点，这个参数的作用是指定一套规则集合，依靠这些规则来判断是否放行数据。这里使用的规则集是<strong>public</strong>，即只放行已配置的服务（端口）。</p>
<p>更详细的可以参考：<a href="http://www.excelib.com/article/287/show/#g5vTC3">Firewalld的结构</a>，<a href="https://www.cnblogs.com/excelib/p/5155951.html">用活Firewalld防火墙中的zone</a></p>
<h1 id="firewall-cmd常用命令"><a href="#firewall-cmd常用命令" class="headerlink" title="firewall-cmd常用命令"></a>firewall-cmd常用命令</h1><p>增加端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定服务</span></span><br><span class="line">firewall-cmd --add-service=http --permanent</span><br></pre></td></tr></table></figure>

<p>移除端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定端口</span></span><br><span class="line">firewall-cmd --permanent --remove-port=80/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定服务</span></span><br><span class="line">firewall-cmd --permanent --remove-service=http</span><br></pre></td></tr></table></figure>

<p>显示防火墙运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure>

<p>仅显示打开的端口信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>

<p>仅显示增加的服务信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-service</span><br></pre></td></tr></table></figure>

<p>显示所有信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<p>配置完之后，必须要重启防火墙让配置生效，如下命令的意思是不中断连接重新加载防火墙配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里只是列举了自己常用的一些命令，更具体的可以参考以下文章</p>
<ul>
<li><p><a href="https://wangchujiang.com/linux-command/c/firewall-cmd.html">firewall-cmd详解</a></p>
</li>
<li><p><a href="http://www.excelib.com/article/287/show/#g5vTC3">Firewalld的结构</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/excelib/p/5155951.html">用活Firewalld防火墙中的zone</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置时区</title>
    <url>/posts/35e905e4.html</url>
    <content><![CDATA[<p>如果服务器在国外且所在时区不一致，那么使用<code>date</code>命令查看时间的话，会看到另外一个时区的时间，为了符合生活习惯需要设置新的时区。</p>
<p>假设一个场景：凌晨3点人少的时候重启服务器。这样写crontab定时任务就有点麻烦了，因为要以自己的时间计算服务器所在时区的时间，因此把服务器时区设置为自己生活所在的时区还是挺有必要的。</p>
<span id="more"></span>

<p>设置方法如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择时区，在这里选了中国时区Asia/Shanghai</span></span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 会提示</span></span><br><span class="line">cp: overwrite ‘/etc/localtime’?</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入确认y</span></span><br><span class="line">cp: overwrite ‘/etc/localtime’? y</span><br></pre></td></tr></table></figure>

<p>PS1：这里只是使用了其中一种方法，其它设置方法可以参考<a href="https://blog.csdn.net/gezilan/article/details/79422864">Linux如何设置时区、时间</a>。</p>
<p>PS2：如果时区对上了，但是具体的时间对不上，可能是没有使用ntp同步互联网时间。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置IPV6地址</title>
    <url>/posts/ef0b8374.html</url>
    <content><![CDATA[<p>一般的服务器都是没有提供IPV6地址的，但是有时候我们又会需要使用到，例如访问谷歌经常会弹出人机验证非常讨厌，这时候使用IPV6进行访问就不需要再验证了。</p>
<span id="more"></span>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统：CentOS 7</p>
<h1 id="免费IPV6"><a href="#免费IPV6" class="headerlink" title="免费IPV6"></a>免费IPV6</h1><p>这是一个免费资源，是由HE（HURRICANE ELECTRIC）提供的，通过技术手段连上HE提供的服务器，实现IPV4转IPV6，我们就间接有了IPV6访问的能力了。</p>
<p>具体的获取教程请参考<a href="https://zhuanlan.zhihu.com/p/344450513">HE的IPV6注册</a>，目的是在HE中获取如下的配置内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe ipv6</span><br><span class="line">ip tunnel add he-ipv6 mode sit remote 216.218.200.58 local 替换你的ipv4地址 ttl 255</span><br><span class="line">ip link set he-ipv6 up</span><br><span class="line">ip addr add 替换获得的ipv6地址 dev he-ipv6</span><br><span class="line">ip route add ::/0 dev he-ipv6</span><br><span class="line">ip -f inet6 addr</span><br></pre></td></tr></table></figure>



<h1 id="自动配置IPV6"><a href="#自动配置IPV6" class="headerlink" title="自动配置IPV6"></a>自动配置IPV6</h1><p>如果直接执行上述的命令，由于这些命令都是临时生效的，每次重启服务器都需要重新执行一次。因此我们要设置为自动执行。操作过程如下</p>
<ol>
<li>首先新建一个脚本ipv6.sh，脚本示例如下</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前目录是：/home/demo 文件具体路径：/home/demo/ipv6.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建脚本ipv6.sh</span></span><br><span class="line">vi ipv6.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 脚本内容如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">modprobe ipv6</span><br><span class="line">ip tunnel add he-ipv6 mode sit remote 216.218.200.58 local 替换你的ipv4地址 ttl 255</span><br><span class="line">ip link set he-ipv6 up</span><br><span class="line">ip addr add 替换获得的ipv6地址 dev he-ipv6</span><br><span class="line">ip route add ::/0 dev he-ipv6</span><br><span class="line">ip -f inet6 addr</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>保存退出后，赋予执行权限</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 授予执行权限</span></span><br><span class="line">chmod +x ipv6.sh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在rc.local文件中加入执行ipv6.sh的命令，最后保存退出，等到下次重启服务器就能看到效果了。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑rc.local脚本</span></span><br><span class="line">vi /etc/rc.local</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入如下内容，记得替换成自己的路径</span></span><br><span class="line">/home/demo/ipv6.sh</span><br></pre></td></tr></table></figure>

<p>rc.local脚本，是Linux系统自带的脚本，每次系统启动时都会执行一遍脚本中的命令，我们就是通过这个机制来自动执行ipv6设置。</p>
<h1 id="检查配置是否生效"><a href="#检查配置是否生效" class="headerlink" title="检查配置是否生效"></a>检查配置是否生效</h1><p>想要立刻重启服务器，可以使用命令<em>reboot</em>，重启后输入网络查看命令<em>ifconfig</em>，找到<em>he-ipv6</em>这个网络接口，如果能找到就代表配置成功了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启服务器</span></span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网络信息</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到he-ipv6这个名字，这个名字是在上面的配置中名命的，不是自动生成的</span></span><br><span class="line">he-ipv6: flags=209&lt;UP,POINTOPOINT,RUNNING,NOARP&gt;  mtu 1480</span><br><span class="line">        inet6 ipv6地址  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 ipv6地址  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        sit  txqueuelen 1000  (IPv6-in-IPv4)</span><br><span class="line">        RX packets 1575  bytes 555832 (542.8 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1654  bytes 407621 (398.0 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="使用IPV6访问"><a href="#使用IPV6访问" class="headerlink" title="使用IPV6访问"></a>使用IPV6访问</h1><p>尝试使用IPV6访问一下谷歌</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ping6 就是用ipv6进行访问</span></span><br><span class="line">ping6 google.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示错误</span></span><br><span class="line">connect: Network is unreachable</span><br></pre></td></tr></table></figure>

<p>（这是我猜的）应该是由于缺少IPV6域名地址的解析能力，无法正确获得IPV6地址，因此访问失败。因此通过在hosts文件中加入谷歌的IPV6地址，尝试绕过解析这一步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改host文件</span></span><br><span class="line">vi /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入谷歌的IPV6地址</span></span><br><span class="line">2404:6800:4008:c00::71 google.com</span><br><span class="line">2404:6800:4008:c02::63 www.google.com</span><br></pre></td></tr></table></figure>

<p>修改完hosts文件后要重新加载网络信息才能生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启网络</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<p>由于上一步重启了网络，因此要重新配置IPV6，执行一下ipv6.sh脚本即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/demo/ipv6.sh</span><br></pre></td></tr></table></figure>

<p>再次访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping6 google.com</span><br><span class="line"></span><br><span class="line">PING google.com(google.com (2404:6800:4008:c00::71)) 56 data bytes</span><br><span class="line">64 bytes from google.com (2404:6800:4008:c00::71): icmp_seq=1 ttl=107 time=224 ms</span><br><span class="line">64 bytes from google.com (2404:6800:4008:c00::71): icmp_seq=2 ttl=107 time=224 ms</span><br><span class="line">64 bytes from google.com (2404:6800:4008:c00::71): icmp_seq=3 ttl=107 time=223 ms</span><br></pre></td></tr></table></figure>

<p>这次就成功了，其中的IPV6地址就是我们在hosts文件中填的那个。</p>
<h1 id="shadowsocks使用IPV6"><a href="#shadowsocks使用IPV6" class="headerlink" title="shadowsocks使用IPV6"></a>shadowsocks使用IPV6</h1><p>使用shadowsocks有个重要用途就是使用谷歌搜索，但是如果IP或者IP段被谷歌标记了的话，经常会弹出人机验证非常讨厌，通过使用IPV6的话就可以避开这个验证。</p>
<p>shadowsocks使用IPV6非常简单，简单的加入如下配置即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑配置文件</span></span><br><span class="line">vi /etc/shadowsocks-libev/config.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入配置项</span></span><br><span class="line">&quot;ipv6_first&quot;:true</span><br></pre></td></tr></table></figure>

<p>然后重启shadowsocks服务即可。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Linux网络配置</title>
    <url>/posts/d2906cb4.html</url>
    <content><![CDATA[<p>每一次使用Linux总是忘记了怎么配置网络，因此特意在这里做一下记录。</p>
<span id="more"></span>

<h1 id="ip命令"><a href="#ip命令" class="headerlink" title="ip命令"></a>ip命令</h1><blockquote>
<p>ip - show/manipulate routing、devices、policy routing and tunnels</p>
</blockquote>
<p>展示或操纵路由、设备、路由策略和隧道。</p>
<p>要修改Linux网络配置，首先要找到自己当前机器上的网卡设备。</p>
<p>注意：这里博主使用的是CentOS7，所以命令是ip，如果使用的是CentOS6的话需要使用ifconfig</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CentOS 7</span></span><br><span class="line">ip address</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS 6</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p>可以看到当前有两个网卡：</p>
<ul>
<li><p>lo：代表的是本地的循回地址</p>
</li>
<li><p>ens33：代表的是自己机器上的网卡，这在不同的机器上有不同的名字。</p>
</li>
</ul>
<p>这时候就需要修改网卡（ens33）对应的网络配置文件了</p>
<p>找到网络配置文件的存放地方，存放的地方是/etc/sysconfig/network-scripts/，配置文件命名格式：ifcfg-网卡名，例如ifcfg-ens33</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure>

<p>使用vi修改文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>

<p>首先说说每个参数</p>
<ul>
<li><p>TYPE：代表了该网卡的类型，Ethernet即以太网</p>
</li>
<li><p>BOOTPROTO：代表了网络的类型，dhcp即动态IP，static即静态IP</p>
</li>
<li><p>ONBOOT：开机就运行 yes-是，no-否</p>
</li>
</ul>
<h1 id="配置动态获取IP地址"><a href="#配置动态获取IP地址" class="headerlink" title="配置动态获取IP地址"></a>配置动态获取IP地址</h1><p>设置配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">BOOTPROTO&#x3D;dhcp</span><br></pre></td></tr></table></figure>
<p>然后重启网络，修改的配置就会生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CenttOS 6</span></span><br><span class="line">service network restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS 7</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<p>以上的方式是最简单的，但是有时候也会带来不便，因为有时侯需要IP地址是固定的</p>
<h1 id="配置静态IP地址"><a href="#配置静态IP地址" class="headerlink" title="配置静态IP地址"></a>配置静态IP地址</h1><p>打开网卡配置文件，修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.14.200 #想固定的IP地址</span><br><span class="line">GATEWAY＝192.168.14.1 # 网关</span><br></pre></td></tr></table></figure>

<p>重启网络即可生效</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx开启Gzip压缩</title>
    <url>/posts/84bf135c.html</url>
    <content><![CDATA[<p>有些资源文件的体积比较大，开启nginx的gzip压缩，能够极大的提升传输的效率。</p>
<span id="more"></span>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统：CentOS 7</p>
<p>Nginx版本：1.16.1</p>
<h1 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h1><p>nginx配置为文件服务器的方式非常简单，打开nginx的配置文件，一般在这个路径下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>然后在http、server、location这三个任一代码块（只是影响了生效的范围）中加入如下关键指令即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启gzip压缩 默认关闭off</span></span><br><span class="line">gzip on;</span><br><span class="line"><span class="meta">#</span><span class="bash">IE版本1-6不支持gzip压缩，关闭</span></span><br><span class="line">gzip_disable &#x27;MSIE[1-6].&#x27;;</span><br><span class="line"><span class="meta">#</span><span class="bash">需要压缩的文件格式 text/html默认会压缩，不用添加</span></span><br><span class="line">gzip_types text/css text/javascript application/javascript image/jpeg image/png image/gif; </span><br><span class="line"><span class="meta">#</span><span class="bash">给响应头加个vary，告知客户端能否缓存</span></span><br><span class="line">gzip_vary on; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认值是 4 4k/8k，设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 例如 4 4k 代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。 4 8k 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存。</span></span><br><span class="line">gzip_buffers 4 8k;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩等级1~9，默认值1，1级别最低压缩速度最快但是压缩比最小，9级别最高压缩速度最慢但压缩比最大，建议根据自己情况测试一下那个级别适合自己，偷懒的话网上看的大多数都是设成1或者4</span></span><br><span class="line">gzip_comp_level 1; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认值0 文件大小大于该值时才进行压缩，单位为Byte，写1k即1024B，当值为0时所有页面都进行压缩，建议设置成大于1k的字节数</span></span><br><span class="line">gzip_min_length 1k; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个不熟悉</span></span><br><span class="line">gzip_proxied # 默认关闭off 用于反向代理的时候是否开启压缩，具体参数建议看下文的参考文章</span><br></pre></td></tr></table></figure>

<p>具体示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  ......</span><br><span class="line">  server &#123;</span><br><span class="line">    ......</span><br><span class="line">    location / &#123;</span><br><span class="line">      gzip on;</span><br><span class="line">      gzip_disable &#x27;MSIE[1-6].&#x27;;</span><br><span class="line">      gzip_types text/css text/javascript application/javascript image/jpeg image/png image/gif; </span><br><span class="line">      gzip_buffers 4 4k;</span><br><span class="line">      gzip_comp_level 1;</span><br><span class="line">      gzip_min_length 20;</span><br><span class="line">      gzip_vary on; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完配置文件后检查一下有没有写错（可省略）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p>最后就是让nginx重新加载让配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.nginx.cn/doc/standard/httpgzip.html">Nginx Gzip模块中文参考</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>服务器</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置SSL证书</title>
    <url>/posts/ecc40a95.html</url>
    <content><![CDATA[<p>HTTP连接是不安全的，数据是明文传输的，如果有敏感数据这就直接暴露在互联网环境下是很危险的行为，因此为Nginx配置SSL证书，使用安全的HTTPS进行访问是非常有必要的。</p>
<span id="more"></span>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统：CentOS 7</p>
<p>Nginx版本：1.16.1</p>
<h1 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h1><p>Nginx需要使用到的SSL证书分为了两部分：key和pem，这个证书是唯一的。</p>
<p>具体的获得方式要自己去域名服务提供商里找了，至于SSL是啥，我自己也很难说清楚，请自行百度吧。</p>
<h1 id="SSL配置方式"><a href="#SSL配置方式" class="headerlink" title="SSL配置方式"></a>SSL配置方式</h1><p>nginx配置启用SSL的方式非常简单，打开nginx的配置文件，一般在这个路径下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>然后在server块中加入如下关键指令即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">listen 443 ssl; # 443是默认的HTTPS端口 ssl指的启用SSL安全配置的意思，在较旧的版本中是单独写成ssl on形式</span><br><span class="line"><span class="meta">#</span><span class="bash"> 证书放在了/etc/nginx/cert目录下，由于cert目录与nginx.conf配置文件处于同级目录下，因此可以写成cert/，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是其它地方建议直接写成绝对路径 例如：/home/nginx/cert/cert-file-name.pem</span></span><br><span class="line">ssl_certificate cert/cert-file-name.pem;  # ssl证书 需要将cert-file-name.pem替换成已上传的证书文件的名称。</span><br><span class="line">ssl_certificate_key cert/cert-file-name.key; # ssl证书需要将cert-file-name.key替换成已上传的证书密钥文件的名称。</span><br><span class="line"></span><br><span class="line">ssl_session_timeout 5m; # 会话的超时时间，m指分钟</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; # 加密算法</span><br><span class="line"><span class="meta">#</span><span class="bash">表示使用的加密套件的类型。</span></span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 表示使用的TLS协议的类型。</span><br><span class="line">ssl_prefer_server_ciphers on; # 设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  ......</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl_certificate cert/cert-file-name.pem; </span><br><span class="line">    ssl_certificate_key cert/cert-file-name.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>既然已经开启了SSL实现了HTTPS，那么普通的HTTP传输就不再需要了，但是每次输入网址都要刻意输入<em>https</em>还是很繁琐的，因此加入重定向配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  ......</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80; # http访问的端口</span><br><span class="line">    ......</span><br><span class="line">    rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 无效了。已经重定向永远到不了了</span></span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 有效</span></span><br><span class="line">  server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写后，所有的HTTP访问最终都会重定向到HTTPS，需要注意：这样配置后其它的监听80端口的配置就都失效了，因为都重定向了，需要更新相应的配置了。</p>
<p>写完配置文件后检查一下有没有写错（可省略）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p>最后就是让nginx重新加载让配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>服务器</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置为代理服务器</title>
    <url>/posts/55e0da5c.html</url>
    <content><![CDATA[<p>Nginx作为代理服务器是一个很常见的用途，例如内部有一个tomcat服务但是又不想开放8080端口，通过配置代理可以在只开放80端口的情况下访问到内部的tomcat服务了。</p>
<span id="more"></span>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统：CentOS 7</p>
<p>Nginx版本：1.16.1</p>
<h1 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h1><p>nginx配置为文件服务器的方式非常简单，打开nginx的配置文件，一般在这个路径下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>然后在location块中加入如下关键指令即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> proxy_set_header作用是设置请求头，代理会使部分信息丢失，因此需要重新设置方便获得真实访问信息</span></span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关键 proxy_pass 代理转发需要到达的目的地，可以是其它任何想要访问的地址</span></span><br><span class="line">proxy_pass http://127.0.0.1:3000/;</span><br></pre></td></tr></table></figure>

<p>具体示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  ......</span><br><span class="line">  server &#123;</span><br><span class="line">    ......</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">      proxy_pass http://127.0.0.1:8080/;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完配置后检查一下有没有写错（可省略）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p>最后就是让nginx重新加载让配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
        <category>服务器</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置为文件服务器</title>
    <url>/posts/4eef1a76.html</url>
    <content><![CDATA[<p>我们经常会遇到从远程服务器下载文件的情况，如果直接使用ftp或者sftp的进行下载的话，下载速度总是不甚满意，网络差的话简直让人抓狂要砸键盘了。这情况可以考虑用Nginx做文件服务器，然后使用IDM（设置为32个线程同时工作）下载，那下载速度可是杠杠的带宽都要跑满了。</p>
<span id="more"></span>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统：CentOS 7</p>
<p>Nginx版本：1.16.1</p>
<h1 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h1><p>nginx配置为文件服务器的方式非常简单，打开nginx的配置文件，一般在这个路径下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>然后在location块中加入如下关键指令即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法:	autoindex on | off;</span><br><span class="line">描述：开启或禁用目录浏览功能，默认是禁用</span><br><span class="line"></span><br><span class="line">语法：autoindex_exact_size off|on;</span><br><span class="line">描述：默认为on，显示出文件的确切大小，单位是bytes。一般会改为off，显示出文件的大概大小，单位是kB或者MB或者GB</span><br><span class="line"></span><br><span class="line">语法：autoindex_format html | xml | json | jsonp</span><br><span class="line">描述：设置目录列表的格式，默认是html</span><br><span class="line"></span><br><span class="line">语法：autoindex_localtime on|off;  </span><br><span class="line">描述：on显示文件的本地时间（服务器时间），否则显示文件的GMT时间（如果不是在0时区，则会有对不上时间的烦恼），默认是off</span><br></pre></td></tr></table></figure>

<p>具体示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  ......</span><br><span class="line">  server &#123;</span><br><span class="line">    ......</span><br><span class="line">    location / &#123;</span><br><span class="line">      root /home/demo/download; # 可下载文件的路径</span><br><span class="line">      autoindex on; # 开启目录浏览功能 最关键的一个一定要填</span><br><span class="line">      autoindex_exact_size off; # 不显示文件的大小</span><br><span class="line">      autoindex_format html; # 目录列表的格式是html</span><br><span class="line">      autoindex_localtime on; # 使用本地时间</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完配置文件后检查一下有没有写错（可省略）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p>最后就是让nginx重新加载让配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>开发</category>
        <category>服务器</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之IO操作</title>
    <url>/posts/908ea013.html</url>
    <content><![CDATA[<p>编码过程中，总是绕不开要对文件进行读写操作，本文章讲述的是Python如何进行IO操作。</p>
<span id="more"></span>

<p>在开始前先看一段引用自他人的描述：</p>
<blockquote>
<p>在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
</blockquote>
<p>由以上内容可以知道对文件的读写操作都是通过文件对象（文件描述符）来完成的。</p>
<h1 id="打开文件对象"><a href="#打开文件对象" class="headerlink" title="打开文件对象"></a>打开文件对象</h1><p>要进行读写操作，需要先打开一个文件对象，一般的语法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(目标文件,操作模式) <span class="keyword">as</span> 文件描述符:</span><br><span class="line">  文件描述符.做点什么</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体例子：读文件demo.txt</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;demo.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.read()</span><br></pre></td></tr></table></figure>
<p>需要注意的是：被打开的<em>文件对象</em>在操作完成后<em>一定</em>要调用自身的<em>关闭</em>方法close(例：f.close())来关闭文件对象，释放系统资源，即使依靠特定的写法确保在读写操作后一定会调用到close()方法，但每次都这样写会导致很繁琐，因而python提供了上述的*with..as..*语法，助我们写出更优雅的代码。</p>
<p>打开文件对象使用的方法是*open()*，常用参数如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(file,mode,encoding)</span><br></pre></td></tr></table></figure>
<ul>
<li>file：要操作的目标文件名，如果该文件不存在则会抛出IOError</li>
<li>encoding：指定目标文件读/写时的编码模式（该参数应该只用于文本模式），编码模式默认情况下是与当前系统的编码模式一致。</li>
<li>mode：对目标文件的打开模式<br>a表示append，r表示read，w表示write，+表示读写模式。，b表示二进制，t表示文本模式，t是默认的模式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="left">以读模式打开</td>
</tr>
<tr>
<td align="center">w</td>
<td align="left">以写模式打开</td>
</tr>
<tr>
<td align="center">a</td>
<td align="left">以追加模式打开 (从 EOF 开始, 必要时创建新文件)</td>
</tr>
<tr>
<td align="center">r+</td>
<td align="left">以读写模式打开</td>
</tr>
<tr>
<td align="center">w+</td>
<td align="left">以读写模式打开 (参见 w )</td>
</tr>
<tr>
<td align="center">a+</td>
<td align="left">以读写模式打开 (参见 a )</td>
</tr>
<tr>
<td align="center">rb</td>
<td align="left">以二进制读模式打开</td>
</tr>
<tr>
<td align="center">wb</td>
<td align="left">以二进制写模式打开 (参见 w )</td>
</tr>
<tr>
<td align="center">ab</td>
<td align="left">以二进制追加模式打开 (参见 a )</td>
</tr>
<tr>
<td align="center">rb+</td>
<td align="left">以二进制读写模式打开 (参见 r+ )</td>
</tr>
<tr>
<td align="center">wb+</td>
<td align="left">以二进制读写模式打开 (参见 w+ )</td>
</tr>
<tr>
<td align="center">ab+</td>
<td align="left">以二进制读写模式打开 (参见 a+ )</td>
</tr>
</tbody></table>
<h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><p>读文件时常用的方法有3个：read()、readline()、readlines()</p>
<p>假设文本text.txt的内容如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">First</span><br><span class="line">Second</span><br><span class="line">Third</span><br><span class="line">5th</span><br><span class="line">6th</span><br><span class="line">7th</span><br></pre></td></tr></table></figure>

<h2 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h2><p>read()：一次性读取文本中全部的内容，以字符串的形式返回结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  f.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;First\nSecond\nThird\n5th\n6th\n7th&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="readline"><a href="#readline" class="headerlink" title="readline()"></a>readline()</h2><p>readline()：只读取文本第一行的内容，以字符串的形式返回结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  f.readline()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;First\n&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="readline-1"><a href="#readline-1" class="headerlink" title="readline()"></a>readline()</h2><p>readlines()：读取文本所有内容，并以数列的形式返回结果，一般配合for in使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  f.readlines()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;First\n&#x27;</span>, <span class="string">&#x27;Second\n&#x27;</span>, <span class="string">&#x27;Third\n&#x27;</span>, <span class="string">&#x27;5th\n&#x27;</span>, <span class="string">&#x27;6th\n&#x27;</span>, <span class="string">&#x27;7th&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h1><p>相对于读文件而言，写文件的方法就简单的多，只有一个简单的*write()*方法，如果有大量的内容只要不断的调用write()方法写入就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;write.txt&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  f.write(<span class="string">&quot;hello python&quot;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;write.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  f.read()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello python</span><br></pre></td></tr></table></figure>

<h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><p>Python的序列化与反序列化是通过pickle模块来实现的</p>
<p>pickle.dump()方法把任意对象序列化为字节流，然后就可以写入一个file-like Object之中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(content=<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;demo.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  pickle.dump(d,f)</span><br></pre></td></tr></table></figure>

<p>与dump()相对的就是load()方法，可以把已经序列化的对象反序列化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;demo.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  d = pickle.load(d,f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="built_in">print</span>(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello world</span><br></pre></td></tr></table></figure>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>对于Python的IO操作还有很多没了解到的地方，因而本篇文章还有很多不完善的地方，只能随着不断的使用加深了解，日后再继续完善。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143192607210600a668b5112e4a979dd20e4661cc9c97000">廖雪峰的Python3教程之IO编程</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之Matplotlib</title>
    <url>/posts/58f9dd24.html</url>
    <content><![CDATA[<p>Matplotlib是Python中最常用的可视化工具之一，可以非常方便地创建海量类型地2D图表和一些基本的3D图表。</p>
<span id="more"></span>

<h1 id="scatter"><a href="#scatter" class="headerlink" title="scatter"></a>scatter</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matplotlib.pyplot.scatter(x, y, s=<span class="literal">None</span>, c=<span class="literal">None</span>, marker=<span class="literal">None</span>, cmap=<span class="literal">None</span>, norm=<span class="literal">None</span>, vmin=<span class="literal">None</span>, vmax=<span class="literal">None</span>, alpha=<span class="literal">None</span>, linewidths=<span class="literal">None</span>, verts=<span class="literal">None</span>, edgecolors=<span class="literal">None</span>, hold=<span class="literal">None</span>, data=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure>

<p>作用：绘制x与y的散点图，具有不同的标记大小和颜色</p>
<p>详细说明：x与y的<strong>维度及其长度必须一致</strong>的数组，通过在x与y数组中的同一位置的数据就构成了在直角座标系中的坐标(x,y)，从而构成了散点图中的其中一个点。</p>
<p>参数</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">参数说明</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">x,y</td>
<td align="left">维度及其长度必须一致的数组</td>
<td align="left">数据的位置</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">标量或者与x,y的shape相同的数组；大小计算：指定数值的二次方</td>
<td align="left">数据标记的大小</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">颜色、序列或颜色的序列</td>
<td align="left">数据标记的颜色</td>
</tr>
</tbody></table>
<p>scatter的颜色说明</p>
<p>可选值：</p>
<ol>
<li>单一颜色格式的字符串</li>
<li>长度为n的颜色序列</li>
<li>使用cmap和norm将n个数字映射到颜色的序列</li>
<li>一个二维数组，其中行是RGB或RGBA</li>
</ol>
<p>注意：参数不应该是单个RGB或RGBA数值，因为它难以与数组的值进行色彩映射。如果要为所有点指定相同的RGB或RGBA值，请使用单行的二维数组。</p>
<table>
<thead>
<tr>
<th align="left">缩写</th>
<th align="left">颜色字符串</th>
</tr>
</thead>
<tbody><tr>
<td align="left">b</td>
<td align="left">blue</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">cyan(青色、蓝绿色)</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">green</td>
</tr>
<tr>
<td align="left">k</td>
<td align="left">black</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">magenta(紫红色)</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">red</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">white</td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">yellow</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.scatter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<p>效果：<img src="/images/matplotlib/scatter01.png" alt="x,y为一维数组"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.scatter([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br></pre></td></tr></table></figure>

<p>效果：<img src="/images/matplotlib/scatter02.png" alt="x,y为二维数组"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.scatter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>效果：<img src="/images/matplotlib/scatter03.png" alt="散点图标记的大小"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.scatter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">50</span>,,<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>效果：<img src="/images/matplotlib/scatter04.png" alt="散点图标记的颜色"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://matplotlib.org/index.html">MatplotLib参考文档</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之科学计算包Numpy</title>
    <url>/posts/cabfbce9.html</url>
    <content><![CDATA[<p>在本文章中将会记录科学计算包Numpy的常用方法，并不断更新。</p>
<span id="more"></span>

<h1 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h1><p>作用：探测数组的维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = array([[<span class="number">0.0</span>,<span class="number">0.1</span>,<span class="number">0.2</span>],[<span class="number">1.0</span>,<span class="number">1.1</span>,<span class="number">1.2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape</span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape[<span class="number">0</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape[<span class="number">1</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="tile"><a href="#tile" class="headerlink" title="tile"></a>tile</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tile(A,B)</span><br></pre></td></tr></table></figure>

<p>作用:重复A，B<em>次（B可以是int类型，也可以是元组类型）</em></p>
<p>当B是int类型时，在列方向上重复B次，行默认1次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tile([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tile([[<span class="number">0.0</span>,<span class="number">0.1</span>],[<span class="number">1.0</span>,<span class="number">1.1</span>]],<span class="number">3</span>)</span><br><span class="line">array([[<span class="number">0.</span> , <span class="number">0.1</span>, <span class="number">0.</span> , <span class="number">0.1</span>, <span class="number">0.</span> , <span class="number">0.1</span>],</span><br><span class="line">       [<span class="number">1.</span> , <span class="number">1.1</span>, <span class="number">1.</span> , <span class="number">1.1</span>, <span class="number">1.</span> , <span class="number">1.1</span>]])</span><br></pre></td></tr></table></figure>

<p>当B是元组类型时，分别在对应维度重复指定次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tile([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>

<h1 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h1><p>作用：给定轴上数组元素的和</p>
<p>假设存在三维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">  ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape(arr)</span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>当没有指定axis时，是求整个数组的和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(arr)</span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<p>当指定axis时，是求该axis(轴)的和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(arr,axis=<span class="number">0</span>)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(arr,axis=<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">9</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(arr,axis=<span class="number">2</span>)</span><br><span class="line">array([[ <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">9</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure>

<p>注意：当指定axis时，对所求出的和再进行求和最终是等于不加axis时的值</p>
<p>参考传送门<a href="http://blog.csdn.net/rifengxxc/article/details/75008427">python 中 np.sum()函数 通俗易懂理解！</a></p>
<h1 id="argsort"><a href="#argsort" class="headerlink" title="argsort"></a>argsort</h1><p>作用：对数组进行排序，并按从小到大返回相应的索引值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>argsort([<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line">array([<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>argsort([[<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>]])</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>

<p>当指定axis时，根据指定axis(轴)进行排序*(axis默认值为-1，即最后一轴)*</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>argsort([[<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>]],axis=<span class="number">0</span>)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这里数组只有两维，即axis=1与默认的axis=-1等效</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>argsort([[<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>]],axis=<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>

<p>参考传送门<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.argsort.html#numpy.argsort">argsort</a></p>
<h1 id="zeros"><a href="#zeros" class="headerlink" title="zeros"></a>zeros</h1><p>作用：创建指定维度和类型并以0填充的数组。</p>
<p>创建一维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>zeros(<span class="number">5</span>)</span><br><span class="line">array([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br></pre></td></tr></table></figure>

<p>创建多维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>zeros((<span class="number">5</span>,<span class="number">2</span>))</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<h1 id="min"><a href="#min" class="headerlink" title="min"></a>min</h1><p>作用：给定轴上数组的最小值</p>
<p>假定三维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = array([</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">8</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">24</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">21</span>]</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">7</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">19</span>],</span><br><span class="line">    [<span class="number">20</span>,<span class="number">12</span>,<span class="number">22</span>,<span class="number">13</span>],</span><br><span class="line">    [<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">21</span>]</span><br><span class="line">  ]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>当没有参数时，返回数组元素中的最小元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">min</span>()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当指定参数时，求该轴上的最小值，参数范围为[0,shape - 1]，shape的值为数组维度数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[[ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">6</span>, <span class="number">11</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">15</span>,  <span class="number">3</span>, <span class="number">21</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">7</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">21</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">min</span>(<span class="number">0</span>)</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">6</span>, <span class="number">11</span>,  <span class="number">2</span>],</span><br><span class="line">       [<span class="number">14</span>, <span class="number">15</span>,  <span class="number">3</span>, <span class="number">21</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">min</span>(<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">3</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">13</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">min</span>(<span class="number">2</span>)</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">12</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure>

<h1 id="max"><a href="#max" class="headerlink" title="max"></a>max</h1><p>作用：给定轴上数组的最大值</p>
<p>假定三维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = array([</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">8</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">24</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">21</span>]</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">7</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">19</span>],</span><br><span class="line">    [<span class="number">20</span>,<span class="number">12</span>,<span class="number">22</span>,<span class="number">13</span>],</span><br><span class="line">    [<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">21</span>]</span><br><span class="line">  ]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>当没有参数时，返回数组元素中的最小元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">max</span>()</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>当指定参数时，求该轴上的最小值，参数范围为[0,shape - 1]，shape的值为数组维度数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[[ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">6</span>, <span class="number">11</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">15</span>,  <span class="number">3</span>, <span class="number">21</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">7</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">21</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">max</span>(<span class="number">0</span>)</span><br><span class="line">array([[ <span class="number">7</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">21</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">max</span>(<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">24</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">21</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">21</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">max</span>(<span class="number">2</span>)</span><br><span class="line">array([[ <span class="number">9</span>, <span class="number">11</span>, <span class="number">24</span>],</span><br><span class="line">       [<span class="number">19</span>, <span class="number">22</span>, <span class="number">21</span>]])</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html">Numpy官方文档</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内建方法</title>
    <url>/posts/Infinity.html</url>
    <content><![CDATA[<p>在本文章中将会记录Python常用的方法，并且将会不断更新。</p>
<span id="more"></span>

<h1 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sorted</span>(<span class="params">iterable, cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">False</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>作用：接受一个可迭代对象，返回一个排序后的list对象</p>
<p>参数：</p>
<ol>
<li>iterable：接受一个可迭代的对象（因为sorted实现了迭代协议，所以接受的参数不一定需要list，可以迭代的对象就可以，也就是鸭子类型）</li>
<li>cmp：在python3.x中已被移除</li>
<li>key：指定一个方法用于每一个列表元素进行比较；python提供了便利的方法去访问方法,在<em>operator</em>模块中有<em>itemgetter()</em>, <em>attrgetter()</em>, 和*methodcaller()*方法。</li>
<li>reverse：升序或降序。True：降序；False：升序。默认升序。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],reverse=<span class="literal">False</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h1 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params"><span class="built_in">object</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>作用：返回字符串、列表、字典、元组等长度</p>
<p>参数：<br>1.object：要计算的字符串、列表、字典、元组等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;12345&#x27;</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(&#123;<span class="string">&quot;first&quot;</span>:<span class="number">1</span>,<span class="string">&quot;second&quot;</span>:<span class="number">2</span>,<span class="string">&quot;third&quot;</span>:<span class="number">3</span>&#125;)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>((<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="strip-、lstrip-、rstrip"><a href="#strip-、lstrip-、rstrip" class="headerlink" title="strip()、lstrip()、rstrip()"></a>strip()、lstrip()、rstrip()</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S.strip([chars])</span><br></pre></td></tr></table></figure>

<p>作用：删除前导和后缀字符并返回字符串；当不加参数时，默认删除前后空格；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&#x27; abcd &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span></span><br><span class="line"><span class="string">&#x27; abcd &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>.strip()</span><br><span class="line"><span class="string">&#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据类型</title>
    <url>/posts/9f07ae5c.html</url>
    <content><![CDATA[<p>Python数据类型</p>
<span id="more"></span>

<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h1><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classmates = (<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</p>
<p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p>
<h1 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h1><p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;first&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;second&#x27;</span>:<span class="number">75</span>,<span class="string">&#x27;Third&#x27;</span>:<span class="number">65</span>&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;first&#x27;</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get(key[,default=<span class="literal">None</span>])</span><br></pre></td></tr></table></figure>

<p>key – 字典中要查找的键。</p>
<p>default – 可选参数，如果指定键的值不存在时，返回该值，默认为 None。</p>
<p>返回值 – 返回指定键的值，如果指定键的值不在字典中返回指定值，默认为 None。</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python常见运算符</title>
    <url>/posts/56b69528.html</url>
    <content><![CDATA[<h1 id="与"><a href="#与" class="headerlink" title="与*"></a><em>与</em>*</h1><p>在计算中，*代表相乘，**代表乘方</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>*<span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常用命令</title>
    <url>/posts/ed3b1c3a.html</url>
    <content><![CDATA[<p>Redis常用命令汇总。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">键命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">DEL key</td>
<td align="left">该命令用于在 key 存在时删除 key</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">DUMP key</td>
<td align="left">序列化给定 key ，并返回被序列化的值</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">EXISTS key</td>
<td align="left">检查给定 key 是否存在</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">EXPIRE key seconds</td>
<td align="left">为给定 key 设置过期时间，以秒计</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">EXPIREAT key timestamp</td>
<td align="left">EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">PEXPIRE key milliseconds</td>
<td align="left">设置 key 的过期时间以毫秒计</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">PEXPIREAT key milliseconds-timestamp</td>
<td align="left">设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">KEYS pattern</td>
<td align="left">查找所有符合给定模式( pattern)的 key</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">MOVE key db</td>
<td align="left">将当前数据库的 key 移动到给定的数据库 db 当中</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">PERSIST key</td>
<td align="left">移除 key 的过期时间，key 将持久保持</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">TTL key</td>
<td align="left">以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">PTTL key</td>
<td align="left">以毫秒为单位返回 key 的剩余的过期时间</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">RANDOMKEY</td>
<td align="left">从当前数据库中随机返回一个 key</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">RENAME key newkey</td>
<td align="left">修改 key 的名称</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">RENAMENX key newkey</td>
<td align="left">仅当 newkey 不存在时，将 key 改名为 newkey</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left">TYPE key</td>
<td align="left">返回 key 所储存的值的类型</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">字符串命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">SET key value</td>
<td align="left">设置指定 key 的值</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">GET key</td>
<td align="left">获取指定 key 的值</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">GETRANGE key start end</td>
<td align="left">返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">GETSET key value</td>
<td align="left">将给定 key 的值设为 value ，并返回 key 的旧值(old value)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">GETBIT key offset</td>
<td align="left">对 key 所储存的字符串值，获取指定偏移量上的位(bit)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">MGET key1 [key2..]</td>
<td align="left">获取所有(一个或多个)给定 key 的值</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">SETBIT key offset value</td>
<td align="left">对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">SETEX key seconds value</td>
<td align="left">将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">SETNX key value</td>
<td align="left">只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">SETRANGE key offset value</td>
<td align="left">用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">STRLEN key</td>
<td align="left">返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">MSET key value [key value …]</td>
<td align="left">同时设置一个或多个 key-value 对</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">MSETNX key value [key value …]</td>
<td align="left">同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">PSETEX key milliseconds value</td>
<td align="left">这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">INCR key</td>
<td align="left">将 key 中储存的数字值增一</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left">INCRBY key increment</td>
<td align="left">将 key 所储存的值加上给定的增量值（increment）</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left">NCRBYFLOAT key increment</td>
<td align="left">将 key 所储存的值加上给定的浮点增量值（increment）</td>
</tr>
<tr>
<td align="center">18</td>
<td align="left">DECR key</td>
<td align="left">将 key 中储存的数字值减一</td>
</tr>
<tr>
<td align="center">19</td>
<td align="left">DECRBY key decrement</td>
<td align="left">key 所储存的值减去给定的减量值（decrement）</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left">APPEND key value</td>
<td align="left">如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">哈希命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">HDEL key field1 [field2]</td>
<td align="left">删除一个或多个哈希表字段</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">HEXISTS key field</td>
<td align="left">查看哈希表 key 中，指定的字段是否存在</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">HGET key field</td>
<td align="left">获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">HGETALL key</td>
<td align="left">获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">HINCRBY key field increment</td>
<td align="left">为哈希表 key 中的指定字段的整数值加上增量 increment</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">HINCRBYFLOAT key field increment</td>
<td align="left">为哈希表 key 中的指定字段的浮点数值加上增量 increment</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">HKEYS key</td>
<td align="left">获取所有哈希表中的字段</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">HLEN key</td>
<td align="left">获取哈希表中字段的数量</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">HMGET key field1 [field2]</td>
<td align="left">获取所有给定字段的值</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">HMSET key field1 value1 [field2 value2 ]</td>
<td align="left">同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">HSET key field value</td>
<td align="left">将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">HSETNX key field value</td>
<td align="left">只有在字段 field 不存在时，设置哈希表字段的值</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">HVALS key</td>
<td align="left">获取哈希表中所有值</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td align="left">迭代哈希表中的键值对</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">列表命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">BLPOP key1 [key2 ] timeout</td>
<td align="left">移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">BRPOP key1 [key2 ] timeout</td>
<td align="left">移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">BRPOPLPUSH source destination timeout</td>
<td align="left">从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">LINDEX key index</td>
<td align="left">通过索引获取列表中的元素</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">LINSERT key BEFORE&#124;AFTER pivot value</td>
<td align="left">在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">LLEN key</td>
<td align="left">获取列表长度</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">LPOP key</td>
<td align="left">移出并获取列表的第一个元素</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">LPUSH key value1 [value2]</td>
<td align="left">将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">LPUSHX key value</td>
<td align="left">将一个值插入到已存在的列表头部</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">LRANGE key start stop</td>
<td align="left">获取列表指定范围内的元素</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">LREM key count value</td>
<td align="left">根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。<br/>COUNT 的值可以是以下几种：<br/>count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT ；<br/>count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值；<br/>count = 0 : 移除表中所有与 VALUE 相等的值。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">LSET key index value</td>
<td align="left">通过索引设置列表元素的值</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">LTRIM key start stop</td>
<td align="left">对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">RPOP key</td>
<td align="left">移除列表的最后一个元素，返回值为移除的元素</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">RPOPLPUSH source destination</td>
<td align="left">移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left">RPUSH key value1 [value2]</td>
<td align="left">在列表中添加一个或多个值</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left">RPUSHX key value</td>
<td align="left">为已存在的列表添加值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">集合命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">SADD key member1 [member2]</td>
<td align="left">向集合添加一个或多个成员</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">SCARD key</td>
<td align="left">获取集合的成员数</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">SDIFF key1 [key2]</td>
<td align="left">返回给定所有集合的差集</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">SDIFFSTORE destination key1 [key2]</td>
<td align="left">返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">SINTER key1 [key2]</td>
<td align="left">返回给定所有集合的交集</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">SINTERSTORE destination key1 [key2]</td>
<td align="left">返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">SISMEMBER key member</td>
<td align="left">判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">SMEMBERS key</td>
<td align="left">返回集合中的所有成员</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">SMOVE source destination member</td>
<td align="left">将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">SPOP key</td>
<td align="left">移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">SRANDMEMBER key [count]</td>
<td align="left">返回集合中一个或多个随机数</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">SREM key member1 [member2]</td>
<td align="left">移除集合中一个或多个成员</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">SUNION key1 [key2]</td>
<td align="left">返回所有给定集合的并集</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">SUNIONSTORE destination key1 [key2]</td>
<td align="left">所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td align="left">迭代集合中的元素</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">有序集合命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">ZADD key score1 member1 [score2 member2]</td>
<td align="left">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">ZCARD key</td>
<td align="left">获取有序集合的成员数</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">ZCOUNT key min max</td>
<td align="left">计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">ZINCRBY key increment member</td>
<td align="left">有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">ZINTERSTORE destination numkeys key [key …]</td>
<td align="left">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">ZLEXCOUNT key min max</td>
<td align="left">在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">ZRANGE key start stop [WITHSCORES]</td>
<td align="left">通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td align="left">通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td>
<td align="left">通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">ZRANK key member</td>
<td align="left">返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">ZREM key member [member …]</td>
<td align="left">移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">ZREMRANGEBYLEX key min max</td>
<td align="left">移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">ZREMRANGEBYRANK key start stop</td>
<td align="left">移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">ZREMRANGEBYSCORE key min max</td>
<td align="left">移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">ZREVRANGE key start stop [WITHSCORES]</td>
<td align="left">返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left">ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td align="left">返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left">ZREVRANK key member</td>
<td align="left">返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td align="center">18</td>
<td align="left">ZSCORE key member</td>
<td align="left">返回有序集中，成员的分数值</td>
</tr>
<tr>
<td align="center">19</td>
<td align="left">ZUNIONSTORE destination numkeys key [key …]</td>
<td align="left">计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left">ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td align="left">迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发</category>
        <category>缓存</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的3种持久化方式</title>
    <url>/posts/9589c4d2.html</url>
    <content><![CDATA[<p>redis提供3种持久化机制用于在重启机器或者系统故障后重用数据（恢复场景）。</p>
<span id="more"></span>


<h1 id="方式一：RDB"><a href="#方式一：RDB" class="headerlink" title="方式一：RDB"></a>方式一：RDB</h1><p>RDB（snapshotting，快照，redis快照）某一时刻下redis的数据副本。默认的持久化方式。</p>
<h1 id="方式二：AOF"><a href="#方式二：AOF" class="headerlink" title="方式二：AOF"></a>方式二：AOF</h1><p>AOF（append-only file，只追加文件）：只有会更改redis中的数据的执行命令才会写入硬盘中的AOF文件。AOF由三种保存策略：1.no（让操作系统决定何时写入AOF文件）；2.always（每次发生数据修改都会写入AOF文件，严重降低redis性能）；3.everysec（每秒钟一次写入AOF，可以一次性将多个写入个命令）。AOF持久化方式实时性更好，是主流的持久化方案，而且使用everysec的策略，能够兼顾数据和写入性能，性能几乎没有损失，即使系统储问题也只是丢失1秒内的数据。</p>
<h1 id="方式三：RDB和AOF混合"><a href="#方式三：RDB和AOF混合" class="headerlink" title="方式三：RDB和AOF混合"></a>方式三：RDB和AOF混合</h1><p>RDB和AOF混合，在AOF重写时把RDB的内容写到AOF文件开头，好处是结合了RDB和AOF的有点，快速加载的同时避免丢失过多的数据，缺点是AOF的文件可读性较差。</p>
<h1 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h1><p>AOF重写：redis生成一个新的AOF文件，其保存的数据状态和旧的AOF文件一致，但体积更小（进行了命令优化，排除了无效的命令）。重写期间，redis会维持一个aof重写缓冲区，记录服务器在重写的这段时间执行的修改数据的命令，重建完后，把缓冲区的数据追加到新的AOF文件的末尾，就是一个新的经过重写的AOF文件了，同时也能保持与服务器种的数据状态的一致了。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>缓存</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的5种基本数据类型</title>
    <url>/posts/7b35ed44.html</url>
    <content><![CDATA[<p>redis有5种基本数据类型：string，list，hash，set，sorted set。</p>
<span id="more"></span>

<p>使用场景如下：    </p>
<p>string：简单的key-value类型，是二进制安全的。一般用在需要计数的场景，比如：用户的访问次数、热点文章的点赞转发数量等。</p>
<p>list：链表（redis实现的是双向链表），一般应用于发布与订阅或者说消息队列、慢查询</p>
<p>hash：是一个string类型的field和value的映射表。特别适用于存储对象，后续操作时，可以直接仅仅修改对象中某个字段的值。</p>
<p>set：无序集合，集合中的元素没有先后顺序且没有重复数据。适用于存放的数据不能重复以及获取多个数据源交集和并集等场景。</p>
<p>sorted set：与set相比增加了一个权重参数score，能使集合中的元素按照score进行有序排列，适用于需要对数据根据某个权重进行排序的场景，比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为消息维度的消息排行榜）等信息。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>缓存</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的淘汰策略</title>
    <url>/posts/e0bb8399.html</url>
    <content><![CDATA[<p>redis共有8种淘汰策略。具体可分成3种类型。</p>
<span id="more"></span>

<h1 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h1><p>类型一<br>no-eviction：禁止淘汰数据，当内存不足无法写入新数据时会报错，真实项目中应该没有人会使用。</p>
<p>类型二（对所有数据而言）<br>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）<br>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</p>
<p>类型三（对于设置了过期时间的数据而言）<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>volatile-ttl（time to live）：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</p>
<p>其中volatile-lfu和allkeys-lfu是4.0之后才加入的策略。</p>
<h1 id="关于LFU和LRU的理解"><a href="#关于LFU和LRU的理解" class="headerlink" title="关于LFU和LRU的理解"></a>关于LFU和LRU的理解</h1><p>LFU按访问频次排序，一个数据被访问则频次+1，淘汰时，把频次最低的淘汰。<br>LRU按访问时间排序，淘汰时，把访问时间最旧的淘汰。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>淘汰策略分为了可淘汰和不可淘汰两部分。可淘汰中根据目标数据范围分为了：所有数据和设置了过期时间 这两类，主要的淘汰策略是：随机（random）、最近最少使用（lru）和最不经常使用（lfu），对于设置了过期时间的数据而言还有一个策略就是挑选将要过期的数据（ttl）。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>缓存</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/posts/b8f4bd70.html</url>
    <content><![CDATA[<p>本篇文章主要讲述的是搭建<strong>Hexo + Github Page + Travis CI</strong>的博客环境。</p>
<p>目前有许多搭建个人博客的方案，但是使用Github Page来展示自己的个人博客，无疑是一个较好的方案，无需额外的服务器、免费、自带CDN、可靠并且自带网站域名，这种种的优势足以让人做出选择，然后加上美观的主题，就可以搭建出一个完整的博客系统了，当然要是有点懒的话，加上Travis CI进行自动部署，就可以专注于博客文章的编写了。</p>
<span id="more"></span>

<p><em>开始前的题外话：在这里我已假设你拥有git的使用知识。</em></p>
<h1 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h1><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<p>由上述Hexo官网引用可以知道，Hexo是一个博客框架，通过解析Markdown文件，把Markdown文件中的文章内容进行渲染并生成我们所看的网页，即我们通常看到的博客文章。</p>
<p>使用Hexo之前<img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g18iaybxqnj20vc0buweu.jpg" alt="使用Hexo之前"></p>
<p>使用Hexo之后<img src="https://ws1.sinaimg.cn/large/e6dffef4gy1g18ie323nyj20os0ef3zl.jpg" alt="使用Hexo之后"></p>
<p>通过以上的配图可以看到，使用Hexo的前后的变化是很大的。</p>
<h1 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h1><blockquote>
<p><a href="https://pages.github.com/">Github Pages</a>主要是用于个人、组织、或者项目的网站，直接把网站代码托管在GitHub仓库上，别人就能访问到该网站，你只需要编辑并推送代码，你对网站的修改就能生效。<br><em>注意:GitHub Pages仅支持静态网站。</em></p>
</blockquote>
<h2 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h2><p>使用<strong>GitHub Pages</strong>来部署博客代码，需用到GitHub仓库，因而拥有一个GitHub的账号是必须的。<a href="https://github.com/join">&gt;&gt;&gt;传送门&lt;&lt;&lt;</a></p>
<h2 id="创建博客代码仓库"><a href="#创建博客代码仓库" class="headerlink" title="创建博客代码仓库"></a>创建博客代码仓库</h2><p>根据GitHub Pages的官网介绍，GitHub Pages主要用于个人网站、组织网站和项目网站，它们的配置如下：</p>
<table>
<thead>
<tr>
<th align="left">网站类型</th>
<th align="left">网站域名与仓库名</th>
<th align="left">分支名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">个人网站</td>
<td align="left">username.github.io</td>
<td align="left">master</td>
</tr>
<tr>
<td align="left">组织网站</td>
<td align="left">orgname.github.io</td>
<td align="left">master</td>
</tr>
<tr>
<td align="left">个人所拥有的项目</td>
<td align="left">username.github.io/projectname</td>
<td align="left">master、gh-pages或者master分支下的docs文件夹下</td>
</tr>
<tr>
<td align="left">组织所拥有的项目</td>
<td align="left">orgname.github.io/projectname</td>
<td align="left">master、gh-pages或者master分支下的docs文件夹下</td>
</tr>
</tbody></table>
<p>由上面的表格可以看到，对不同类型的网站，在仓库的命名和推送的目标分支仅有略微的差别，而对于要搭建个人博客的我们，关注点就在<strong>第一行</strong>上<em>（当然，聪明的你完全可以依照本篇文章的方法为自己的项目搭建一个网站出来）</em>。</p>
<p>参照上面的配置表格，根据自己GitHub上的用户名<em>username</em>，创建一个仓库并命名为：<strong>username.github.io</strong><br>与此同时，你的个人网站也拥有了相应的域名也就是仓库名<em>username.github.io</em>，以后你或者其他人就能通过该域名访问到你的网站。</p>
<h2 id="master分支与hexo分支"><a href="#master分支与hexo分支" class="headerlink" title="master分支与hexo分支"></a>master分支与hexo分支</h2><p>由上面的表格可以了解到，对于个人网站而言，网站代码必须存放于master分支上，GitHub Pages才能生效，而对于我们生成博客网站前的博客代码，我则存放于hexo分支上（读者可以放到其它地方或者其它分支上，只要最后博客网站代码正确推送到username.github.io仓库的master分支上即可）。<br><strong>master分支：存放最终生成的博客网站代码；</strong><br><strong>hexo分支：存放博客源代码；</strong></p>
<h1 id="博客配置"><a href="#博客配置" class="headerlink" title="博客配置"></a>博客配置</h1><p>在这里我选择了Hexo做为博客框架，当然如果感兴趣的读者也可以研究一下其它的博客框架。</p>
<h2 id="Hexo博客框架"><a href="#Hexo博客框架" class="headerlink" title="Hexo博客框架"></a>Hexo博客框架</h2><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<p>Hexo博客框架依赖于node.js来运行并生成静态页面。</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>在这里建议下载稳定版LTS（<a href="https://nodejs.org/en/">&gt;&gt;&gt;下载传送门&lt;&lt;&lt;</a>），以提供一个相对稳定的博客编写环境。下载并安装后，打开命令行界面，输入命令<em>node -v</em>，如果安装成功将会返回版本信息，如下图所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">8.9.4</span><br></pre></td></tr></table></figure>

<h3 id="安装Hexo博客框架"><a href="#安装Hexo博客框架" class="headerlink" title="安装Hexo博客框架"></a>安装Hexo博客框架</h3><p>打开命令行界面，输入如下命令，安装全局的Hexo命令，方便后续的博客编写操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>然后输入如下命令，安装hexo博客框架代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init 这里写存放博客代码的路径</span><br></pre></td></tr></table></figure>

<p>进入博客代码文件夹内，安装Hexo博客框架运行所需的依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>至此一个可运行的Hexo博客框架就搭建完成了，如果需要了解更多关于Hexo的使用方法，可点击<a href="https://hexo.io/zh-cn/docs/setup.html">&gt;&gt;这里&lt;&lt;</a>。</p>
<h2 id="Next博客主题"><a href="#Next博客主题" class="headerlink" title="Next博客主题"></a>Next博客主题</h2><p>博客主题对于博客来说是极其重要的，在这里我选择了使用Next主题，Next主题拥有众多的开发者，也被众多的博客所使用，因而能够保持着足够的活力，同时也能够在遇到问题的时候寻求到帮助。</p>
<p>为了方便余下篇幅的描述，作出以下约定：</p>
<ol>
<li>站点配置文件：Hexo博客根目录下一个名为*_config.yml*的文件，里面存放着整个博客站点的配置信息；</li>
<li>主题配置文件：在Hexo博客所引用的主题文件里也存在着一个名为*_config.yml*的文件，但与站点配置文件不同的是里面存放的是该主题的配置信息；</li>
<li>主题文件夹：Hexo博客根目录下有一个thems文件夹，里面存放着博客的主题资源；</li>
</ol>
<h3 id="主题安装基本步骤"><a href="#主题安装基本步骤" class="headerlink" title="主题安装基本步骤"></a>主题安装基本步骤</h3><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>关于主题的具体下载方式，在这里暂且跳过，后续由专门的章节来进行讲解。<br>在这里假设我们已经下载好主题文件，并把主题文件夹命名为<em>next</em>（这里你可以命名为任何合法的名字，只需要在下一个步骤里填入相同的名字就可以了），把主题文件放置在<em>主题文件夹</em>内。</p>
<h4 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h4><p>Hexo博客在博客创建的时候就已经自带了一个主题，而要切换为自带的博客主题，就需要修改<em>站点配置文件</em>，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>到这里博客就能够使用新的博客主题了。</p>
<h3 id="主题下载方式"><a href="#主题下载方式" class="headerlink" title="主题下载方式"></a>主题下载方式</h3><p>主题的下载方式决定了后续过程中对该主题进行个性化定制后升级的难易程度。</p>
<h4 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h4><p>直接下载，顾名思义就是直接下载整个主题，使用这种方式有一个弊端：在主题升级或者修复bug之后，主题的升级都需要去主题站点重新下载整个主题并替换掉旧的主题，费时费力；其次对于高度个性化定制主题之后，更是难以进行升级操作。因而<strong>强烈不推荐这种方式</strong>。</p>
<h4 id="git-clone下载"><a href="#git-clone下载" class="headerlink" title="git clone下载"></a>git clone下载</h4><p>使用<em>git clone</em>方式下载主题至主题文件夹内，是主题发布方的推荐方式，该种方式能够及时且方便的获取主题的最新版本，并且能够在高度个性化定制主题后能够轻松的保留更改的同时升级主题。</p>
<p>主题下载：进入博客根目录，打开命令行界面（<em>注意路径为博客根目录</em>），执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>

<p>执行结束后主题文件夹下就多了一个叫next的文件夹，同时里面也存放有主题相关的资源文件。</p>
<p>主题更新：进入Next主题文件夹，打开命令行界面（<em>注意路径为博客根目录</em>），执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>如果更新遇到问题，可以参考<a href="https://github.com/theme-next/hexo-theme-next">&gt;&gt;&gt;这里&lt;&lt;&lt;</a></p>
<h4 id="git子模块下载"><a href="#git子模块下载" class="headerlink" title="git子模块下载"></a>git子模块下载</h4><p>使用<em>git submodule</em>方式下载主题，是无法对主题内容进行高度个性定制化的，仅仅能够在Next主题允许的范围内对主题进行个性定制，优点就是在保留一定程度的定制化的同时能够轻松对主题进行升级（比<em>git clone</em>方法还要方便）。</p>
<p>主题下载：进入博客根目录，打开命令行界面（<em>注意路径为博客根目录</em>），执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>

<p>执行结束后主题文件夹下就多了一个叫next的文件夹，同时里面也存放有主题相关的资源文件。</p>
<p>主题更新：进入博客根目录，打开命令行界面（<em>注意路径为博客根目录</em>），执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>

<p>使用该种方式对主题的定制化，是通过在站定配置文件追加<em>theme_config</em>字段实现的，只要是主题配置文件中存在的字段就能够在<em>theme_config</em>字段下使用(<em>注意缩进</em>)，并且作用到主题中。例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="comment"># 主题</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line">  <span class="comment"># 头像</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">/images/avatar.png</span></span><br><span class="line">  <span class="comment"># 菜单</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">    <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>

<h3 id="数学公式渲染"><a href="#数学公式渲染" class="headerlink" title="数学公式渲染"></a>数学公式渲染</h3><p>写博客的过程中可能会遇到需要编写数学公式的情景，要是使用图片来代替的话就不太优雅了，这时候可以考虑使用数学渲染引擎来直接渲染出数学公式了，幸运的是Next主题已经替我们准备好了。Next主题提供了两个渲染引擎：mathjax和katex，mathjax渲染速度较慢，但是支持的范围较广，katex渲染速度快，但是支持的范围较窄，因此博主选择了mathjax，以下内容也以mathjax为例，如果有需要的读者可自行查询文档：<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md">katex安装</a></p>
<p>首先卸载hexo自带的渲染工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>

<p>然后安装新的渲染工具，根据官方文档说，mathjax只能在hexo-renderer-kramed和hexo-renderer-pandoc中二选一，在这里博主选择了hexo-renderer-kramed</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-kramed --save # or hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>

<p>在站点配置文件中，写入如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">math:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">engine:</span> <span class="string">mathjax</span></span><br><span class="line">    <span class="attr">mathjax:</span></span><br><span class="line">      <span class="attr">cdn:</span> <span class="string">//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p>即可使博客网站具备渲染数学公式的能力，更多的配置可在主题配置文件（Next/_config.yml）的math部分查看。</p>
<p>然后在需要进行数学公式渲染的markdown文件中，开头部分加入mathjax: true，即可让数学渲染引擎对该文件进行渲染，如果不需要进行数学渲染的切记不要添加，因为会有损性能。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>如果成功了的话，就能看到你现在所看到的数学公式了<br>$$<br>f(n) =<br>\begin{cases}<br>n/2,  &amp; \text{if $n$ is even} \<br>3n+1, &amp; \text{if $n$ is odd}<br>\end{cases}<br>$$</p>
<h1 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h1><p>一篇新的博客文章需要经历三个步骤才能出现在博客中：</p>
<ol>
<li>写文章</li>
<li>生成GitHub Pages用的博客代码（hexo generate）</li>
<li>提交上述的生成的博客代码（git push）</li>
</ol>
<p>要是每次写一遍新的文章都要经历如上三个步骤多繁琐呀！要是能把第二个步省略掉，自己只专注于写博客，然后提交新的文章，文章就能自动出现在博客中那该多好呀，使用Travis CI就能达到这个目的，替我们完成这与创作无关的步骤。</p>
<h2 id="GitHub权限配置"><a href="#GitHub权限配置" class="headerlink" title="GitHub权限配置"></a>GitHub权限配置</h2><p>使用Travis CI来自动部署网站代码，必须对代码仓库进行设置，同时需要授予Travis CI相应的权限，而GitHub已经提供了相应的开发者接口，并且有一套完善安全的接口调用方法。</p>
<h3 id="获取Access-Token"><a href="#获取Access-Token" class="headerlink" title="获取Access Token"></a>获取Access Token</h3><ol>
<li>登陆GitHub</li>
<li>进入个人设置页面（点击自己的头像图标-&gt;Settings）</li>
<li>点击左侧栏下的Developer settings（Personal settings-&gt;Developer settings）</li>
<li>点击Personal access tokens</li>
<li>这个时候就能看到如下图所示的界面，点击Generate new token按钮<img src="/images/blog/generatenewtoken.png" alt="Generate new token界面"></li>
<li>填写Token description（凭据描述,方便以后自己的辨别），选中repo下的publish_repo选项（授予Travis CI的权限），如下图所示：<img src="/images/blog/newpersonalaccesstoken.png" alt="New Personale Access Token">然后点击下方的Generate token（保存设置）</li>
<li>点击保存后回到步骤5的界面，这时候会显示一串字符，这就是Travis CI所需要的凭据<strong>（注意：立刻保存好这串字符，因为该字符串仅在第一次显示，并且为了自己的代码安全不要告诉他人这串字符的任何信息）</strong><img src="/images/blog/accesstoken.png" alt="Access Token"></li>
</ol>
<h3 id="GitHub仓库配置"><a href="#GitHub仓库配置" class="headerlink" title="GitHub仓库配置"></a>GitHub仓库配置</h3><ol>
<li>登陆GitHub</li>
<li>进入<em>username.github.io</em>仓库</li>
<li>点击仓库上方的Settings按钮<img src="/images/blog/reposetting.png" alt="Settings"></li>
<li>点击左侧栏的Integrations &amp; services-&gt;点击右侧的Add services按钮-&gt;输入并选中Travis CI，如下图所示<img src="/images/blog/addservice.png" alt="Add Services"></li>
<li>点击下方的绿色Add service</li>
</ol>
<p>至此，在GitHub方面的配置就完成了。</p>
<h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><blockquote>
<p>Travis CI是一个提供持续集成的服务，能够与GitHub很好的结合起来。Travis CI对于GitHub的开源仓库是免费的，对于私有仓库是需要收费的。</p>
</blockquote>
<h3 id="Travis-CI注册"><a href="#Travis-CI注册" class="headerlink" title="Travis CI注册"></a>Travis CI注册</h3><p>要使用Travis CI当然要先注册一个账号<a href="https://www.travis-ci.org/">&gt;&gt;&gt;传送门&lt;&lt;&lt;</a>，而Travis CI允许使用GitHub的账号作为第三方授权登陆。</p>
<h3 id="Travis-CI配置"><a href="#Travis-CI配置" class="headerlink" title="Travis CI配置"></a>Travis CI配置</h3><p>当使用GiHub授权登陆Travis CI的时候，Travis CI就能感知到我们仓库的状态，这时候就要设置究竟是那个仓库要进行持续集成了。</p>
<ol>
<li>点击头像图标进入如下界面：<img src="/images/blog/tciselectrepo.png" alt="GitHub仓库列表"></li>
<li>选中username.github.io仓库（按钮变为绿色）</li>
<li>点击旁边的小齿轮，进入仓库的具体设置页面</li>
<li>点击右侧的more options-&gt;选择Settings<img src="/images/blog/tcisettingheader.png" alt="Travis CI Setting header"></li>
<li>按下图选中对应的选项<img src="/images/blog/tcisettingcontent.png" alt="Travis CI Setting Content"></li>
<li>在Environment Variables部分中，写入环境变量GITHUB_TOKEN，值为上述提到的Token，然后点击add按钮添加</li>
</ol>
<p>至此在Travis CI的配置就完成了。</p>
<h2 id="博客源代码配置"><a href="#博客源代码配置" class="headerlink" title="博客源代码配置"></a>博客源代码配置</h2><p>Travis CI服务的使用，除了需要在Travis CI和GitHub中进行配置外，还需要在博客根目录下添加一个名为.travis.yml的文件，这个配置文件告诉了Travis CI如何工作，配置文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo博客框架是依赖于node.js环境来运行的</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># 指定node.js的版本</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"><span class="comment"># 缓存依赖文件，提高构建的速度</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;node_modules&quot;</span></span><br><span class="line"><span class="comment"># 指定对什么分支才进行构建</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="comment"># 这里替换成自己的分支</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">your-github-branch</span></span><br><span class="line"><span class="comment"># 安装hexo所需要的依赖</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="comment"># 构建时执行的动作，这里是生成博客的网站代码</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="comment"># 推送网站代码到github</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 这里引用上一步中所填入的Token</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 将要推送到github的代码位置，这里是指向Hexo生成的博客网站代码的文件夹</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">./public</span></span><br><span class="line">  <span class="comment"># 推送的目标分支</span></span><br><span class="line">  <span class="attr">target-branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># 构建结果的通知对象</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">your-email</span></span><br><span class="line">  <span class="comment"># 提交者</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">commiter</span></span><br><span class="line">  <span class="comment"># 推送前的条件判断</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="comment"># 本次构建来自指定分支才进行推送，预防有多分支时造成的误推送（这里与前面都点重复）</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">your-github-branch</span></span><br><span class="line"><span class="comment"># 设置邮件通知，构建成功或失败都进行通知</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span></span><br><span class="line">    <span class="attr">on_success:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">on_failure:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>经过上述的三个配置步骤，博客的自动部署就设置完成了，现在我们写一篇博客文章只需要：</p>
<ol>
<li>写博客文章</li>
<li>推送文章内容到GitHub仓库</li>
</ol>
<p>然后剩下的就交给Travis CI来完成了，它将会代替我们生成网站代码并部署到GitHub仓库上，我们只要耐心的等待一下，就能在网站上看到效果了。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>网络上关于Hexo博客搭建的文章很多，如果有人能读到本篇文章，希望能给你带来一点帮助！</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://help.github.com/categories/github-pages-basics/">GitHub Pages帮助文档</a><br><a href="https://hexo.io/zh-cn/docs/setup.html">Hexo帮助文档</a><br><a href="http://theme-next.iissnan.com/">Next主题</a><br><a href="https://docs.travis-ci.com/">Travis CI帮助文档</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>斐讯N1刷机后操作</title>
    <url>/posts/b9577586.html</url>
    <content><![CDATA[<p>N1刷机成功后，为了方便使用，免不了要执行一些常见的配置操作或软件安装，例：更换国内软件源、安装docker、设置WIFI、安装Java环境等。</p>
<span id="more"></span>

<h1 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h1><p>本示例系统使用的是armbian 5.67 stretch 4.19</p>
<h1 id="设置WiFi"><a href="#设置WiFi" class="headerlink" title="设置WiFi"></a>设置WiFi</h1><p>要设置WiFi可以使用系统自带的网络设置图形界面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure>

<p>执行命令后，通过方向键和回车键选中其中的<em>Activate a connection</em>选项，将会弹出一个列表（<em>Wired</em>代表的是有线连接，<em>WiFi</em>代表的是无线连接），按提示输入WiFi账号密码即可。</p>
<p>如果图形界面中没有WiFi列表则说明系统的WiFi模块有问题，可按如下方法解决：</p>
<p>方法一： 执行如下命令重新加载模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modprobe dhd &amp;&amp; echo dhd &gt;&gt; &#x2F;etc&#x2F;modules</span><br><span class="line">modprobe wifi_dummy &amp;&amp; echo wifi_dummy &gt;&gt; &#x2F;etc&#x2F;modules</span><br></pre></td></tr></table></figure>

<p>方法二：使用armbian-config命令设置wifi</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行命令</span><br><span class="line">armbian-config</span><br></pre></td></tr></table></figure>

<p>依据提示选中Network中的WIFI</p>
<p>方法三：重新安装系统。</p>
<h1 id="更换国内源"><a href="#更换国内源" class="headerlink" title="更换国内源"></a>更换国内源</h1><p>重要的事情说三遍</p>
<p>如果默认源的安装速度不是特别慢的话，无需特意跟换源！！！</p>
<p>如果默认源的安装速度不是特别慢的话，无需特意跟换源！！！</p>
<p>如果默认源的安装速度不是特别慢的话，无需特意跟换源！！！</p>
<p>/etc/apt/sources.list文件记录的是系统所使用的软件源，而默认安装的系统使用的是国外源</p>
<p>首先对/etc/apt/sources.list文件进行备份，以备不时之需</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</span><br></pre></td></tr></table></figure>

<p>然后编辑/etc/apt/sources.list文件，把原有的源删除，并加入新的国内源（这里使用的是科大的源，如果需要的可以自行更换为其它源，如：163、清华等），并保存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line"></span><br><span class="line"># 科大软件源</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch main non-free contrib</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch-updates main non-free contrib</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch-backports main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch-updates main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch-backports main non-free contrib</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian-security&#x2F; stretch&#x2F;updates main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian-security&#x2F; stretch&#x2F;updates main non-free contrib</span><br></pre></td></tr></table></figure>

<p>最后执行更新命令，使软件列表生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure>

<p>等待命令执行完，至此新的软件源就生效了。</p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>安装docker有一个非常便捷的方法就是使用阿里提供的一键安装脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>通过脚本直接安装docker及其所需的依赖，可以说是非常方便了。</p>
<p>注意：该脚本会直接安装最新的docker脚本</p>
<h1 id="安装JRE"><a href="#安装JRE" class="headerlink" title="安装JRE"></a>安装JRE</h1><p>有时候需要运行Java程序，因此JRE（Java运行时环境）是必不可少的。</p>
<p>执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装java8的jre</span><br><span class="line">apt-get install openjdk-8-jre</span><br></pre></td></tr></table></figure>

<p>注意点一：如果安装过程中遇到所需依赖无法下载的问题，可能是由apt源造成的。博主之前使用的是科大软件源，结果提示部分依赖缺少无法下载，然后跟换回默认源就可以了。</p>
<p>注意点二：博主一开始是从Oracle官网下载的解压包：server-jre-8u212-linux-x64.tar.gz，并用其配置环境，但是在尝试执行命令的时候却报错：<em>cannot execute binary file: Exec format error</em>，这是因为该解压包的文件目标运行系统和本系统（参考：阅读须知）有差异而导致的，需要指定的版本才能在本系统运行。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://luotianyi.vc/1389.html">Armbian系统重新加载WiFi模块</a></p>
<p><a href="https://www.hostloc.com/thread-527652-1-1.html">N1求教连接wifi问题，实在不知道咋回事了</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>CAP理论和BASE理论</title>
    <url>/posts/7ae49b47.html</url>
    <content><![CDATA[<p>说起分布式肯定绕不开两个理论：CAP理论和BASE理论。限于水平有限，本篇文章仅作记录用。</p>
<span id="more"></span>



<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>C即一致性，A即可用性，P即分区容错性。<br>CAP理论指出了三者中只能同时做到其中的两个，无法同时满足三个要求。<br>CAP理论是针对分布式数据库环境提出的，因此P属性是必须的。如果选择了A，那么分区间的数据可能会不一致；如果选择了C，则为了保持数据一致性而导致服务不可用。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Spring cloud中的eureka 属于AP，zookeeper属于CP。</p>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BA（基本可用，Basically Available）、S（软状态，Soft-state）、C（最终一致性，Eventually Consistent）<br>BASE理论是由CAP理论发展而来，是一致性和可用性权衡的结果，即牺牲一致性来满足系统的可用性，然后在后续的过程中达到最终一致。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>基础知识</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS操作和ABA问题</title>
    <url>/posts/ce4f4d1f.html</url>
    <content><![CDATA[<p>多线程开发中，通常会加锁做并发控制，但是加锁会让性能降低，因此有了CAS操作，但CAS操作会引发ABA问题。</p>
<span id="more"></span>



<h1 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h1><p>CAS（Compare and Swap，比较和交换），是一种乐观锁（同时操作同一个对象的概率非常小，因此大部分加锁操作做的都是无用功）的实现方式，是以一种无锁的方式实现并发控制，即在多线程环境下，以不加锁的方式对数据进行修改。</p>
<h2 id="CAS的操作过程"><a href="#CAS的操作过程" class="headerlink" title="CAS的操作过程"></a>CAS的操作过程</h2><p>CAS（V，E，N），V表示要更新变量的值（变量当前值），E表示预期值（变量的旧值），N表示新值。</p>
<p>仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做更新，则当前线程则什么都不做。</p>
<p>最后，CAS 返回当前V的真实值。</p>
<h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><p>ABA问题，是指CAS操作中，其它线程把变量的值进行了修改但是修改的值与原始值一致，使CAS的比较判断出错，即无法感知数据被修改过，导致程序异常。</p>
<p>避免方法：加入版本号进行记录，CAS操作时比较一下版本号就能判断出是不是属于自己的那次CAS操作了。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>基础知识</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>临界段</title>
    <url>/posts/c3329247.html</url>
    <content><![CDATA[<p>临界段即多线程互斥使用共享资源的代码段，是一种加锁的机制，在任意时刻一个共享资源只能被一个线程使用。</p>
<p>Java中使用关键字synchronized定义临界段，能对共享对象进行加锁操作。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>基础知识</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程间的互斥和同步</title>
    <url>/posts/6117b918.html</url>
    <content><![CDATA[<p>多线程间是互相协助和互相联系的，因此多线程间存在互斥和同步。</p>
<span id="more"></span>

<h1 id="互斥和同步"><a href="#互斥和同步" class="headerlink" title="互斥和同步"></a>互斥和同步</h1><p>多线程间存在并发访问共享资源（修改资源）时就会出现互斥，保证共享数据在同一时刻只被一个线程使用。</p>
<p>多线程同步是指一个线程由于某种原因（等待对象释放之类的）需要等待另一个线程执行完才能继续执行的现象，即线程间互相等待。</p>
<p>互斥和同步是不可分离的，互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式，互斥是因，同步是果，互斥是方法，同步是目的。</p>
<h1 id="Java中的实现"><a href="#Java中的实现" class="headerlink" title="Java中的实现"></a>Java中的实现</h1><p>Java中wait()、notify()、notifyAll()三个方法就是用来实现线程同步的。</p>
<p>wait()处于等待队列，或超时结束等待。notify()通知第一个处于等待的线程，notifyAll()则唤醒所有等待线程一起竞争cpu。</p>
<p>Java中最基本的互斥同步手段就是synchronized。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>基础知识</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间的通信方式</title>
    <url>/posts/44e8cd7.html</url>
    <content><![CDATA[<p><strong>进程通信(Interprocess Communication，IPC)是一个进程与另一个进程间共享消息的一种通信方式</strong>。消息(message)是发送进程形成的一个消息块，将消息内容传送给接收进程。</p>
<span id="more"></span>



<h1 id="进程间通信的目的"><a href="#进程间通信的目的" class="headerlink" title="进程间通信的目的"></a>进程间通信的目的</h1><ul>
<li><p>数据传输<br> 一个进程需要将其数据发送给另一进程，发送的数据量在一个字节到几M字节之间。</p>
</li>
<li><p>共享数据<br> 多个进程操作共享数据</p>
</li>
<li><p>事件通知<br> 一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p>
</li>
<li><p>资源共享<br> 多个进程之间共享同样的资源。<strong>为了作到这一点，需要内核提供锁和同步机制</strong>。</p>
</li>
<li><p>进程控制<br> 有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
</li>
</ul>
<h1 id="8种通信方式"><a href="#8种通信方式" class="headerlink" title="8种通信方式"></a>8种通信方式</h1><ol>
<li><p>匿名管道</p>
<p>是一种半双工的通信方式（即数据只能单向流动），且只能在具有亲缘关系的进程间使用（亲缘关系指的父子进程或者兄弟子进程），该管道只存在于内存之中。</p>
</li>
<li><p>流管道</p>
<p>是一种全双工的通信方式（即数据能双向流动）</p>
<p>注：对该方法不熟悉，请自行搜索更多相关内容</p>
</li>
<li><p>命名管道</p>
<p>与匿名管道一样是一种半双工的通信方式（即数据只能单向流动），但<em>克服了匿名管道只能在具有亲缘关系的进程间使用的限制</em>，允许无亲缘关系的进程间使用，管道以一种特殊设备文件形式存在于文件系统中。</p>
</li>
<li><p>信号</p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p>消息队列</p>
<p>是消息的链表，存放在内核中，一个消息队列由一个标识符（即队列ID）来标识。</p>
<p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
<p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
<p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
<li><p>共享内存</p>
<p>两个或多个进程共享一个给定的存储区，是最快的一种 IPC，因为进程是直接对内存进行存取。</p>
<p>因为多个进程可以同时操作，所以需要进行同步。</p>
<p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p>
</li>
<li><p>信号量</p>
<p>信号量是一个计数器，用于实现进程间的互斥与同步，若要在进程间传递数据需要结合共享内存。</p>
<p>信号量是基于操作系统的PV操作，程序对信号量的操作都是原子操作。</p>
<p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
<p>支持信号量组。</p>
</li>
<li><p>套接字，即socket通信，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
</li>
</ol>
<h1 id="进程间的通信和线程间的通信的区别"><a href="#进程间的通信和线程间的通信的区别" class="headerlink" title="进程间的通信和线程间的通信的区别"></a>进程间的通信和线程间的通信的区别</h1><p>只有进程间需要通信，线程间由于共享进程的地址空间，因此没有通信必要，但要做好同步和互斥，保护共享的变量。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>基础知识</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Conda</title>
    <url>/posts/c3592b96.html</url>
    <content><![CDATA[<p>Conda是一个包管理、依赖管理和<em>环境管理</em>工具，虽然由Python程序创建，但它可以打包并分发任何语言的软件，例如：Python, R, Ruby, Lua, Scala, Java, JavaScript, C/ C++, FORTRAN。</p>
<span id="more"></span>

<h1 id="Conda简介"><a href="#Conda简介" class="headerlink" title="Conda简介"></a>Conda简介</h1><blockquote>
<p>Conda是一个开源的包管理、依赖管理和环境管理工具，能运行在Windows、macOS和Linux上，具备快速安装、运行和更新包和依赖的能力，能够轻松的创建、保存、加载和切换不同的开发环境。虽然Conda由Python程序创建，但它可以打包并分发任何语言的软件。</p>
</blockquote>
<p>通过以上摘录自官网的译文可以知道，Conda对于经常要切换不同的开发环境的开发者来说，是一个极其合适的工具。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>Conda作为一个管理工具，有两个常见的发行版本：Anaconda和Miniconda，其区别如下：</p>
<p>Miniconda：仅仅拥有python，conda和一些必须的依赖包,除此之外没有任何附带的东西，操作时需要使用命令行的方式进行操作，占用极小的硬盘空间，但使用的时候需要自己安装所需要的包。<a href="https://conda.io/miniconda.html">&gt;&gt;&gt;下载&lt;&lt;&lt;</a></p>
<p>Anaconda：拥有Miniconda所拥有的之外，还自带超过720个的开源包，并且具有图形化的操作界面，安装后即可使用，但占用较大的空间，以及会安装一些自己使用不到的包。<a href="https://www.anaconda.com/download/">&gt;&gt;&gt;下载&lt;&lt;&lt;</a></p>
<p>综上来看：两个发行版该有的基本功能一样不缺，但相对而言，Miniconda更适合一些简约的人使用，如果需要省心的话Anaconda就是一个极好的选择，毕竟多占的一些硬盘空间对现在的硬盘来说不算什么，读者可以根据自身情况进行选择。</p>
<p>博主比较喜欢简约因此使用的是Miniconda，同时为了更好的熟悉conda，下面将会直接使用命令行来进行操作演示。</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>在安装conda的过程中，其中有一个选项就是把conda加入系统环境变量中，官方提示是不建议勾选，因为重装之类的可能会导致找不到相应目录之类的，建议直接使用官方提供的命令行工具，在命令行下找到一个名为<em>Anaconda Prompt</em>的应用，如下所示：<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppvqnx28j206w016aa2.jpg" alt="Anaconda Prompt"><br>运行后的效果如下所示：<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppw9j5u6j20p50c2aa8.jpg" alt="Anaconda Prompt CMD"><br>但是经过一段时间的使用后发现还是加入到系统的环境变量中更方便，这样就可以随时随地在任何环境中使用了，如果已经安装了程序但又没有加入系统环境变量的，可以按照如下步骤重新加入：</p>
<ol>
<li>找到程序的安装根目录，要是安装时没有指定安装目录的话，一般都是安装在安装时使用的用户的用户目录之下，这里假设路径是conda_rootdir<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppwjwa75j20pk0gy0uf.jpg" alt="conda安装根目录"></li>
<li>打开系统环境变量的设置窗口：我的电脑点击鼠标右键-&gt;属性-&gt;高级系统设置-&gt;环境变量<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppwvx4znj211u0i8b1e.jpg" alt="系统环境变量"></li>
<li>在系统变量部分，找到变量名为Path的条目，选中并点击下方的编辑按钮，就能打开编辑界面<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppx5njzxj20q00imdh7.jpg" alt="系统环境变量编辑窗口"></li>
<li>把如下的路径添加到系统环境变量中，记得把conda_rootdir替换为自己电脑下conda的安装根目录<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppxihyuxj20bc034mx0.jpg" alt="conda路径"></li>
<li>点击确定，保存编辑的内容，然后重新打开命令行窗口，然后输入命令<em>conda info</em>，并显示相应内容的话，就表示配置成功，配置失败的请重新配置<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppxqdloaj20rl0e5t95.jpg" alt="conda信息"></li>
</ol>
<h1 id="conda配置文件"><a href="#conda配置文件" class="headerlink" title="conda配置文件"></a>conda配置文件</h1><p>conda安装后会在用户目录下生成一个配置文件*.condarc*，如果没有的话可以自己创建一个，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br></pre></td></tr></table></figure>
<p>配置文件中的channels属性指的是安装时的下载来源，defaults指的是默认的下载来源，如果想添加下载源的话只要按照格式添加就可以了。默认源在国内下载速度较慢，所以国内有清华镜像源即<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">Anaconda 镜像</a>，使用后速度会有明显的提升，但是在这里依然不建议使用国内的清华源，因为使用一段时间后发现清华源的版本比较旧而且还不全，直接使用默认源的话使用上是基本没有问题，下载时间也就相对清华源慢一些而已。</p>
<p>默认情况下环境文件以及下载下来的包都是安装在软件根目录下的envs和pkgs文件夹下，如果想要更改安装路径的话，可以加入如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境目录</span></span><br><span class="line"><span class="attr">envs_dirs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">E:\Documents\Code\alpha\conda\envs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包目录</span></span><br><span class="line"><span class="attr">pkgs_dirs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">E:\Documents\Code\alpha\conda\pkgs</span></span><br></pre></td></tr></table></figure>

<p>如果有想了解更多的可以直接访问官网了解详细的配置<a href="https://conda.io/docs/user-guide/configuration/use-condarc.html">&gt;&gt;&gt;传送门&lt;&lt;&lt;</a></p>
<h1 id="Conda信息"><a href="#Conda信息" class="headerlink" title="Conda信息"></a>Conda信息</h1><p>如果想要查看Conda的信息的话，可以输入如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure>
<p><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppxqdloaj20rl0e5t95.jpg" alt="conda信息"><br>可以看到上一部分的配置信息也出现在内容展示中，说明配置是有效的。</p>
<p>如果想要查看已有的开发环境，输入如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda info --env</span><br></pre></td></tr></table></figure>
<p><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppybug74j20fx02kt8i.jpg" alt="conda环境信息"><br>可以看到里面现在有两个环境，分别是base和tensorflow，其中base就是安装时默认的环境，而tensorflow就是博主自己创建的环境。</p>
<p>在上述图片中还有个要注意的地方就是base环境前面是有个*号的，说明base环境处于激活的状态，即判断当前所处环境的方法就是查看*号出现在那个环境前。<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppyn28j4j20g303q0sm.jpg" alt="激活了tensorflow环境"><br>而上面这张则是激活了tensorflow环境的，而这张还有一个特别地方就是前面直接写着名为tensorflow的环境名称，因此也可以作为当前处于那个激活环境的判断。</p>
<p>那么到底怎么创建一个新的环境呢？</p>
<h1 id="环境创建、克隆、激活和删除"><a href="#环境创建、克隆、激活和删除" class="headerlink" title="环境创建、克隆、激活和删除"></a>环境创建、克隆、激活和删除</h1><p>想要创建环境，只要输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不指定python版本</span></span><br><span class="line">conda create --name env-name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定python版本</span></span><br><span class="line">conda create --name env-name python=2.7</span><br></pre></td></tr></table></figure>
<p>其中env-name是该新建环境的名称；python是该环境中的python版本，默认情况下如果不写该参数，将会延用base环境中的python版本，而base环境中的python版本就是下载部分选择conda安装包时的python版本。<br><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppyx53v9j20qp05gwec.jpg" alt="conda创建环境"><br>创建成功后就能看到如上的显示，想要激活环境，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate env-name</span><br></pre></td></tr></table></figure>
<p>想要取消激活，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<p>当然，也可以直接关闭命令窗口来退出已激活的环境。</p>
<p>注意：在没有激活任何环境的情况下都是处于base环境之下的，就算激活了其它环境也只在激活的命令窗口下是激活环境，在激活环境下的任何操作，都不会对其它环境产生影响，当然这也就是conda的意义所在。</p>
<p>在某些情况下如果想要复制已有的环境，可以输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create --name new-env-name --clone env-name</span><br></pre></td></tr></table></figure>

<p>如果想删除现有的环境，必须在先取消激活目标环境，然后执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda remove --name env-name --all</span><br></pre></td></tr></table></figure>

<h1 id="包的查看、搜索、安装、更新和卸载"><a href="#包的查看、搜索、安装、更新和卸载" class="headerlink" title="包的查看、搜索、安装、更新和卸载"></a>包的查看、搜索、安装、更新和卸载</h1><p>注意：以下的一切命令请先激活环境后再执行，否则都将会作用于基本环境，即操作的对象是基本环境。</p>
<p>创建好环境后，想要使用当然还需要安装自己所需要的包，这里使用tensorflow做例子，输入如下命令，查看当前已安装的包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
<p><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppz5ky2sj20hn08mq2y.jpg" alt="查看已安装的包"></p>
<p>搜索可用的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda search tensorflow</span><br></pre></td></tr></table></figure>
<p><img src="http://ws1.sinaimg.cn/large/e6dffef4gy1g5ppzem086j20e804xq2t.jpg" alt="搜索可用的包"></p>
<p>安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install tensorflow</span><br></pre></td></tr></table></figure>

<p>更新包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda update tensorflow</span><br></pre></td></tr></table></figure>

<p>卸载已安装的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda uninstall tensorflow</span><br></pre></td></tr></table></figure>

<h1 id="环境配置的导入和导出"><a href="#环境配置的导入和导出" class="headerlink" title="环境配置的导入和导出"></a>环境配置的导入和导出</h1><p>在某些情况下，如果想要分享自己的开发环境，可以通过导出目标环境的环境配置来完成分享。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate tensorflow</span><br><span class="line"></span><br><span class="line">conda env export &gt; path-to/environment.yml</span><br></pre></td></tr></table></figure>
<p>注意：要先激活想要的分享目标环境，然后再执行导出命令</p>
<p>导出命令的path-to是指定目标路径，environment.yml则是导出的环境配置文件，如果不写路径则将会导出到命令行当前的路径之下。</p>
<p>别人拿到了你分享出来的环境配置文件又该如何使用呢，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda env create -f path-to/environment.yml</span><br></pre></td></tr></table></figure>
<p>即可创建一个和环境配置文件描述的一摸一样的开发环境了。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>至此，conda的基本用法已经讲述完，如过想要更深入了解的话可以在官网上查阅更详细的资料。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://conda.io/docs/index.html">conda官网</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>开发工具</category>
        <category>Conda</category>
      </categories>
      <tags>
        <tag>Conda</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见使用问题</title>
    <url>/posts/36fb1fe.html</url>
    <content><![CDATA[<p>Git是使用频率非常高的一个工具，在使用过程中遇到过不少的问题，现在汇总一下遇到过的问题以及对应的解决方法。</p>
<span id="more"></span>



<h1 id="无法访问Github"><a href="#无法访问Github" class="headerlink" title="无法访问Github"></a>无法访问Github</h1><p>Github服务器位于国外，因此经常出现无法访问的情况，影响了代码的拉取和提交等。要解决只能使用代理或者修改hosts文件。</p>
<p>注：值得一提的就是，如果拉取代码的速度慢，也可以考虑通过设置代理来提高下载速度。</p>
<h2 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h2><p>使用代理是比较常见的方法，对于Github网页的访问，直接运行代理软件就可以了，对于Git工具就需要进行配置，对应的代理配置项是<em>http.proxy</em>和<em>https.proxy</em></p>
<p>查看当前代理设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看全局代理配置</span></span><br><span class="line">git config --global http.proxy</span><br><span class="line">git config --global https.proxy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前项目代理配置</span></span><br><span class="line">git config --local http.proxy</span><br><span class="line">git config --local https.proxy</span><br></pre></td></tr></table></figure>

<p>设置代理配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置全局代理配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http代理</span></span><br><span class="line">git config --global http.proxy &#x27;http://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;https://127.0.0.1:1080&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置当前项目代理配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http代理</span></span><br><span class="line">git config --local http.proxy &#x27;http://127.0.0.1:1080&#x27;</span><br><span class="line">git config --local https.proxy &#x27;https://127.0.0.1:1080&#x27;</span><br></pre></td></tr></table></figure>

<p>删除代理配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除全局代理配置</span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前项目代理配置</span></span><br><span class="line">git config --local --unset http.proxy</span><br><span class="line">git config --local --unset https.proxy</span><br></pre></td></tr></table></figure>



<h2 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h2><p>这样方法没用过，请自行搜索解决方案。</p>
<h1 id="不支持具有-socks5-方案的代理"><a href="#不支持具有-socks5-方案的代理" class="headerlink" title="不支持具有 socks5 方案的代理"></a>不支持具有 socks5 方案的代理</h1><p>Git提交代码到远程服务器，虽然提交成功，但显示异常信息，异常信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatal: NotSupportedException encountered.</span><br><span class="line">   ServicePointManager 不支持具有 socks5 方案的代理。</span><br></pre></td></tr></table></figure>

<p>关键词：<em>socks5</em>和<em>代理</em>，这两个词有点熟悉，就是代理设置时经常遇到的字眼，先查看git配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示信息如下</span></span><br><span class="line">......</span><br><span class="line">http.proxy=socks5://127.0.0.1:1080</span><br><span class="line">https.proxy=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>问题就是这里了，<em>http.proxy</em>和<em>https.proxy</em>支持的都是http协议，不能使用socks协议。</p>
<p>因此需要改回使用http协议的代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#x27;http://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;https://127.0.0.1:1080&#x27;</span><br></pre></td></tr></table></figure>

<p>或者考虑不使用代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>



<h1 id="拒绝访问-Connection-refused"><a href="#拒绝访问-Connection-refused" class="headerlink" title="拒绝访问 Connection refused"></a>拒绝访问 Connection refused</h1><p>提交代码到远程时遇到如下问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/xxxxxxxxx.git/&#x27;: Failed to connect to 127.0.0.1 port 1080: Connection refused</span><br></pre></td></tr></table></figure>

<p>这个问题很明显就是配置了代理信息，但是又忘记运行代理软件，导致无法连通远程服务器。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Gogs配置为服务开机自启动</title>
    <url>/posts/bdb89eee.html</url>
    <content><![CDATA[<p><code>Gogs是一款极易搭建的自助 Git 服务</code>，安装起来也确实是这样，在安装目录下输入命令<code>./gogs web</code>就能启动Gogs服务，但如果是通过二进制方式进行安装每次都要输入命令拉起服务就很不方便了，因此需要手动把Gogs配置为Linux服务并开机自启动。</p>
<span id="more"></span>

<p><strong>注：假设当前的操作用户是git（为啥要用git用户下文细说），安装目录是/home/git/gogs ！！！</strong></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>系统：CentOS 7</p>
<p>Gogs版本：0.12.3</p>
<h1 id="配置Gogs服务"><a href="#配置Gogs服务" class="headerlink" title="配置Gogs服务"></a>配置Gogs服务</h1><p>要配置为Linux服务，先要写一个配置脚本，而这一步Gogs已经贴心的帮我们完成了，放在了如下的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/git/gogs/scripts/systemd/gogs.service</span><br></pre></td></tr></table></figure>

<p>然后复制到<code>/usr/lib/systemd/system/</code>目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /home/git/gogs/scripts/systemd/gogs.service /usr/lib/systemd/system/</span><br></pre></td></tr></table></figure>

<p>执行如下命令，让Linux重新加载服务的配置信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>如果不执行这一步会弹出警告信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Warning: gogs.service changed on disk. Run &#x27;systemctl daemon-reload&#x27; to reload units.</span><br></pre></td></tr></table></figure>

<p>到了这里就可以正常使用了。</p>
<h1 id="Gogs服务自启动"><a href="#Gogs服务自启动" class="headerlink" title="Gogs服务自启动"></a>Gogs服务自启动</h1><p>配置好Gogs服务，剩下的就和其它的Linux服务没区别，直接用<code>systemctl</code>命令来控制就可以了。</p>
<p>开启自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable gogs</span><br></pre></td></tr></table></figure>

<p>关闭自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable gogs</span><br></pre></td></tr></table></figure>

<p>手动启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start gogs</span><br></pre></td></tr></table></figure>

<p>手动关闭服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop gogs</span><br></pre></td></tr></table></figure>

<p>查看服务状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status gogs</span><br></pre></td></tr></table></figure>



<h1 id="Gogs默认用户git"><a href="#Gogs默认用户git" class="headerlink" title="Gogs默认用户git"></a>Gogs默认用户git</h1><p>翻看一下Gogs安装目录下的脚本可以发现，很多地方的默认用户都是git，例如上文提到的<code>gogs.service</code>脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开gogs.service脚本</span></span><br><span class="line">vi /home/git/gogs/scripts/systemd/gogs.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">这里只截取了部分内容</span></span><br><span class="line">[Service]</span><br><span class="line"><span class="meta">#</span><span class="bash"> Modify these two values and uncomment them <span class="keyword">if</span> you have</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> repos with lots of files and get an HTTP error 500 because</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of that</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">LimitMEMLOCK=infinity</span></span><br><span class="line"><span class="meta">#</span><span class="bash">LimitNOFILE=65535</span></span><br><span class="line">Type=simple</span><br><span class="line">User=git</span><br><span class="line">Group=git</span><br><span class="line">WorkingDirectory=/home/git/gogs</span><br><span class="line">ExecStart=/home/git/gogs/gogs web</span><br><span class="line">Restart=always</span><br><span class="line">Environment=USER=git HOME=/home/git</span><br></pre></td></tr></table></figure>

<p>因此怕麻烦不想修改脚本的，可以考虑新建一个git用户，不会新建的看这里<a href="https://www.zhixing.icu/archives/linux-cao-zuo-zhi-nan-01--xin-jian-yong-hu">Linux操作指南：01-新建用户</a>。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>开发工具</category>
        <category>Gogs</category>
      </categories>
      <tags>
        <tag>Gogs</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA输出中文乱码解决方法</title>
    <url>/posts/3d0562c8.html</url>
    <content><![CDATA[<p>IDEA输出中文乱码是个常见的问题了，记录下问题的解决方法，以及网上方法无效的原因。</p>
<span id="more"></span>

<p>先上结论：首先要确认是idea的问题，如果是则打开idea，选择help-&gt;Edit Custom VM Options，加入参数-Dfile.encoding=UTF-8，保存并重启，即可解决问题。</p>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>要解决中文乱码问题，首先要知道是哪里导致了中文乱码，才能进行针对性的配置。</p>
<p>定位的方法很简单，就是使用排除法：</p>
<ul>
<li>直接用<em>java -jar</em>直接运行程序</li>
<li>直接用构建工具运行程序</li>
<li>是web程序则直接用tomcat运行</li>
</ul>
<p>这样就很清楚的知道是哪里的问题了。</p>
<p>但是！但是！但是！一般情况下上面的环节其实都是没问题的，主要问题是在idea的身上！</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><blockquote>
<p>windows默认使用GBK，idea新装的时候也是使用GBK</p>
</blockquote>
<p>看到中文乱码，我们会自然的联想到是编码问题，所以会把GBK改为兼容性更好的UTF-8，具体操作如下：</p>
<ol>
<li>打开idea</li>
<li>选中工具栏中的<strong>Help</strong>标签下的<strong>Edit Custom VM Options</strong></li>
<li>加入参数 <strong>-Dfile.encoding=UTF-8</strong></li>
<li>保存并重启idea</li>
</ol>
<p>经过上述步骤，中文乱码就迎刃而解了。</p>
<h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>搜索引擎上能搜索到很多解决idea中文乱码的文章，都是在<strong>vmoptions</strong>中添加参数 <strong>-Dfile.encoding=UTF-8</strong>，但是就是没有效果！为啥？</p>
<p>其实是因为idea在用户目录下有一个<strong>vmoptions</strong>副本！！</p>
<p>跟着文章通常修改的是idea安装目录下的idea.exe.vmoptions和idea64.exe.vmoptions，说白点就是你修改的和idea使用的根本不是同一个，才会导修改没有效果。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/sxdcgaq8080/p/7648400.html">重点在评论14楼</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>开发工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>深入操作系统-01环境创建</title>
    <url>/posts/d1f7f56f.html</url>
    <content><![CDATA[<p>要开发一个操作系统，搭建开发环境是必不可少的，本篇文章就介绍如何使用Linux、bochs搭建开发环境。</p>
<span id="more"></span>

<p>注意：本文章还没有涉及到C语言，所以环境搭建没有涉及到这部分，将会在后续进行补充。</p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>在不考虑其它的情况下，先要知道一个OS源码最后要怎么在机器上运行。</p>
<ol>
<li>编写一个汇编源码文件（a.asm）</li>
<li>使用nasm把汇编文件a.asm编译成二进制文件a.bin</li>
<li>把二进制文件a.bin写入到磁盘中（在开发环境中即a.img）</li>
<li>在bochs使用已写入汇编源码的磁盘（a.img）进行测试运行</li>
</ol>
<p>即源码文件经历了如下流程：.asm -&gt; a.bin -&gt; a.img</p>
<p>现在已经整个开发流程有了一个基本的认知了，下面逐一讲解需要用到的工具。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>是基本的编译环境，其次把编译好的二进制文件写入到磁盘中也需要用到Linux中的指令，即源码的编译与文件的写入都离开不了Linux。</p>
<h1 id="Nasm"><a href="#Nasm" class="headerlink" title="Nasm"></a>Nasm</h1><p>是一个汇编指令的编译软件，能把汇编文件编译成二进制文件。</p>
<h1 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h1><p>已经写好的程序该放到哪里运行呢？放到自己的电脑上，程序有故障怎么办！所以最好的办法是使用虚拟机，可以随便折腾，有问题也不怕，但是我们需要调试程序，所以使用普通的虚拟机也不行。</p>
<p>因此使用bochs就是一个极好的选择，既是虚拟机又带有调试功能。</p>
<p>在这里省略bochs的安装过程，主要看看使用bochs时需要用到的配置文件（注意：文件后缀是bxrc的就是bochs用到的配置文件，例：bochsrc.bxrc）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 为虚拟机分配的内存（RAM）大小，默认单位是MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 这里还没研究</span><br><span class="line">romimage: file&#x3D;$BXSHARE&#x2F;BIOS-bochs-latest</span><br><span class="line">vgaromimage: file&#x3D;$BXSHARE&#x2F;VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 使用的磁盘列表</span><br><span class="line">floppya: 1_44&#x3D;boot.img, status&#x3D;inserted</span><br><span class="line"></span><br><span class="line"># 选择引导磁盘 cdroom即光驱 floppy即软驱 disk即硬盘</span><br><span class="line">boot: floppy</span><br><span class="line"></span><br><span class="line"># 输出的日志文件</span><br><span class="line">log: bochsout.txt</span><br><span class="line"></span><br><span class="line"># 是否启用鼠标</span><br><span class="line">mouse: enabled&#x3D;0</span><br><span class="line"></span><br><span class="line"># 键盘布局</span><br><span class="line">keyboard: keymap&#x3D;$BXSHARE&#x2F;keymaps&#x2F;x11-pc-us.map</span><br></pre></td></tr></table></figure>

<p>注意：上文中提到的$BXSHARE即为bochs的安装目录。</p>
<p>通过配置文件可以知道，要运行我们自己写的操作系统，只需要在配置文件中的磁盘列表加入我们创建的磁盘，并在以到磁盘项中选择我们的磁盘，然后运行bochs即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上便是开发一个操作系统需要的基本开发环境，目前涉及到的C语言部分将在后面完善。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>基础知识</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储IP地址</title>
    <url>/posts/e38e4cbe.html</url>
    <content><![CDATA[<p>在MySQL中，没有专门用于存储IP地址的数据类型，但是可以使用inet_aton()函数把IP地址转换成整型数值进行存储，使用inet_ntoa()函数把整型数值转换回IP地址。</p>
<span id="more"></span>

<h1 id="inet-aton-和inet-ntoa-函数"><a href="#inet-aton-和inet-ntoa-函数" class="headerlink" title="inet_aton()和inet_ntoa()函数"></a>inet_aton()和inet_ntoa()函数</h1><p>inet_aton()和inet_ntoa()是MySQL提供的一对函数，一般情况下都是互相配合使用的：</p>
<ul>
<li>inet_aton()：把IP地址转换成一个整型数值，其中的aton可以理解成 IP Address-&gt;Number</li>
<li>inet_ntoa()：把整型数值转换成IP地址，其中的ntoa可以理解成Number-&gt;IP Address</li>
</ul>
<p>具体的流程：inet_aton(IP地址)—&gt;整型数值，inet_ntoa(整型数值)-&gt;IP地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> select inet_aton(<span class="string">&#x27;255.255.255.255&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 4294967295</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select inet_ntoa(<span class="string">&#x27;4294967295&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 255.255.255.255</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select inet_aton(<span class="string">&#x27;0.0.0.0&#x27;</span>);</span>  </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select inet_ntoa(<span class="string">&#x27;0&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 0.0.0.0</span></span><br></pre></td></tr></table></figure>

<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>在不知道inet_aton()和inet_ntoa()函数存在的情况下，我们会想到使用varchar解决IP地址长度不固定的存储问题。但是为了更高的性能，MySQL为我们提供了专用的函数。</p>
<blockquote>
<p>IP地址范围：0.0.0.0 - 255.255.255.255</p>
</blockquote>
<p>根据IP地址的范围，使用varchar类型，存储IP地址的最小值（0.0.0.0）要占用7个字符，存储IP地址的最大值（255.255.255.255）要占用15个字符，按照一般使用UTF-8编码计算，存储占用在<strong>22~46个字节</strong>之间。</p>
<p>使用inet_aton()函数，IP地址的最大值（255.255.255.255）转换后产生的整型数值为<em>4294967295</em>，即只需要一个int类型即可存储，而一个int类型数据在数据库中只占用<strong>4个字节</strong>。</p>
<p>通过以上的分析可以了解到，使用函数对IP地址转换后进行存储比直接存储字符串在存储空间上要节省得多，其次在运算上也有明显的优势。</p>
<p>注意：因为没有在真实的场景中用IP地址进行过运算，这里没法给出例子，等以后以后遇到了再回来修改！</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL开发时异常记录</title>
    <url>/posts/a7ec3638.html</url>
    <content><![CDATA[<p>记录开发过程中遇到过的MySQL异常。</p>
<span id="more"></span>

<h1 id="Unknown-error-1045"><a href="#Unknown-error-1045" class="headerlink" title="Unknown error 1045"></a>Unknown error 1045</h1><p>数据库的账号密码输入错误。</p>
<h1 id="Data-truncation-22001"><a href="#Data-truncation-22001" class="headerlink" title="Data truncation: #22001"></a>Data truncation: #22001</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: #22001</span><br></pre></td></tr></table></figure>

<p>插入的数据值范围超过了字段在数据库中定义的范围。</p>
<h1 id="The-server-time-zone-value-‘�й���׼ʱ��’-is-unrecognized-or-represents-more-than-one-time-zone"><a href="#The-server-time-zone-value-‘�й���׼ʱ��’-is-unrecognized-or-represents-more-than-one-time-zone" class="headerlink" title="The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone"></a>The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone</h1><p>在较新版本的<em>mysql-connector-java</em>里，需要在连接数据库的url上加入<em>serverTimeZone</em>参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 需要注意serverTimeZone的大小写</span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br></pre></td></tr></table></figure>

<p>一般情况使用参数<em>serverTimezone=Asia/Shanghai</em>，代表中国的时区（UTC+8）</p>
<p>如果有多国的时差问题，直接使用<em>serverTimezone=UTC</em>，即全球标准时间</p>
<p>可用参数参考：<a href="https://blog.csdn.net/Shezzer/article/details/80201264">mysql serverTimezone</a></p>
<h1 id="java-sql-SQLException-HY000"><a href="#java-sql-SQLException-HY000" class="headerlink" title="java.sql.SQLException: #HY000"></a>java.sql.SQLException: #HY000</h1><p>字段在数据库中定义为非空字段，但是插入数据时该字段对应的值却为空。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语言分类</title>
    <url>/posts/d703ab8b.html</url>
    <content><![CDATA[<p>SQL命令可以根据其命令行为划分为5大类：DDL、DML、DCL、TCL、DQL</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">简称</th>
<th align="center">全称</th>
<th align="center">中文</th>
<th align="center">关键词</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DDL</td>
<td align="center">Data Definition Language</td>
<td align="center">数据定义语言</td>
<td align="center">CREATE<br/>DROP <br/>ALTER<br/>RENAME<br/>TRUNCATE</td>
</tr>
<tr>
<td align="center">DML</td>
<td align="center">Data Manipulation Language</td>
<td align="center">数据操纵语言</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DQL</td>
<td align="center">Data Query Language</td>
<td align="center">数据查询语言</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">DCL</td>
<td align="center">Data Control Language</td>
<td align="center">数据控制语言</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TCL</td>
<td align="center">Transaction Control Language</td>
<td align="center">事务控制语言</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>事务操作和事务自动提交</title>
    <url>/posts/11188dee.html</url>
    <content><![CDATA[<p>写了这么久的SQL，怎么手动操作事务竟然快忘了，是时候复习一下了。</p>
<span id="more"></span>



<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>数据库：MySQL 8（注：一定要使用支持事务的引擎，例如：InnoDB，MyISAM是不支持事务的）</p>
<h1 id="显式事务操作"><a href="#显式事务操作" class="headerlink" title="显式事务操作"></a>显式事务操作</h1><p>显式操作事务，无非就是3个动作：开启事务、提交、回滚 。</p>
<p>开启事务有如下两个命令，其效果都是一样的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br></pre></td></tr></table></figure>

<p>提交命令如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<p>回滚命令如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span></span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 提交</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 回滚</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注：这里只是简单的展示了使用方法，复杂的需要用到条件语句，从而判断是使用commit还是rollback。</strong></p>
<h1 id="事务自动提交"><a href="#事务自动提交" class="headerlink" title="事务自动提交"></a>事务自动提交</h1><p>一般情况下数据库都是开启了事务自动提交的，因除非显式的开始一个事务，否则每个查询都被当做一个单独的事务执行。</p>
<p>是否自动提交，可以通过参数<strong>autocommit</strong>设置。通过如下命令查看当前的状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Variable_name</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">autocommit</td>
<td>ON</td>
</tr>
</tbody></table>
<p>ON表示开启自动提交；OFF表示关闭自动提交，需要手动输入<em>commit</em>或<em>rollback</em>才能让事务生效。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 开启自动提交</span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"># 关闭自动提交</span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span>OFF;</span><br></pre></td></tr></table></figure>

<p><strong>注意：设置的时候1和ON、0和OFF的效果是等同的。</strong></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/posts/5874180.html</url>
    <content><![CDATA[<p>事务是数据库中经常碰到的一个概念，总结一下相关知识，汇总对事务的理解。</p>
<span id="more"></span>

<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h1 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h1><ul>
<li>原子性（Atomicity）：事务是最小的操作单位，不允许再分割，原子性确保了操作要么都执行要么都不执行。</li>
<li>一致性（Consistency）：事务执行前后数据保持一致。理解上就是一个基本的转账操作，执行前后总额不变，不能多或少了。</li>
<li>隔离性（Isolation）：并发访问数据库时，一个用户的事务不能被其它事务干扰。</li>
<li>持久性（Durability）：事务提交后，对数据库中的数据的改变是持久的，即使数据库出现故障也不应该对其有任何影响。</li>
</ul>
<h1 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h1><p>为了提高性能，并发是必须的，多个事务经常会操作相同的数据来完成各自的任务，但会引发相关的问题：</p>
<ul>
<li>脏读（dirty-read）：一个事务修改了数据但还没进行提交，这时另一个事务则读取并使用了该数据，这就是脏读。这个数据可能只是一个中间结果，未提交前都是不准确的，依据这样的数据做的处理都是不正确的，对于另一个事务而言，这个数据就是“脏数据”。</li>
<li>丢失修改（lost to modify）：一个事务修改了某个数据，然后另一个事务也紧接着进行了修改，这样第一个事务的修改结果就会丢失。</li>
<li>不可重复读（Unrepeatable read）：一个事务内多次读取同一个数据，事务未结束时，另一个事务对该数据进行了修改，那么第一个事务在两次读取之中，读到了不一样的数据。</li>
<li>幻读（phantom read）：与不可重复读类似，一个事务多次读取多行记录时，另一个事务插入或删除了几行数据，导致第一个事务两次读取之中，读到了不一样的数据。</li>
</ul>
<h3 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h3><p>不可重复读的重点是某行记录的修改，例如：多次读取某个数据，发现数据被修改了。</p>
<p>幻读的重点是多行记录的新增或删除，例如：多次读取数据，返现记录增加或者减少了。</p>
<h1 id="事务的四个隔离级别"><a href="#事务的四个隔离级别" class="headerlink" title="事务的四个隔离级别"></a>事务的四个隔离级别</h1><p>SQL标准定义了四个隔离级别</p>
<p>读取未提交（read-uncommitted）：最低的隔离级别，允许读取尚未提交的数据变更，无法防止：脏读、不可重复读和幻读。</p>
<p>读取已提交（read-committed）：允许读取事务已经提交的数据，可以防止脏读，但是仍无法防止：不可重复读和幻读。</p>
<p>可重复读（repeatable-read）：对同一个数据的多此读取结果都是一样的，除非是被本身的事务所修改，可以防止：脏读、不可重复读，但是仍无法防止：幻读。</p>
<p>串行化（serializable）：最高的隔离级别，所有事务逐个执行，这样事务间就不会互相干扰，但是性能也是最差的，可以防止：脏读、不可重复读以及幻读。</p>
<table>
<thead>
<tr>
<th><em><strong>*隔离级别*</strong></em></th>
<th><em><strong>*脏读*</strong></em></th>
<th><em><strong>*不可重复读*</strong></em></th>
<th><em><strong>*幻读*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>双向链表和双向循环链表</title>
    <url>/posts/12626135.html</url>
    <content><![CDATA[<p>双向链表是一种非常常用的数据结构，在双向链表的基础上还有一个双向循环链表。</p>
<span id="more"></span>



<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>一个元素节点中包含两个额外的指针，一个prev指向前驱节点，一个next指向后继节点</p>
<p><img src="/images/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p>
<h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><p>在双向链表的基础上，尾部元素的next指向链表的头部，头部元素的prev指向链表的尾部</p>
<p><img src="/images/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表"></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis的占位符</title>
    <url>/posts/daf2aad3.html</url>
    <content><![CDATA[<p>代码中访问数据库的时候，经常需要传输参数用作语句条件，这就不得不用到MyBatis提供的占位符。</p>
<span id="more"></span>



<h1 id="占位符：-和"><a href="#占位符：-和" class="headerlink" title="占位符：#{ } 和 ${ }"></a>占位符：#{ } 和 ${ }</h1><p>MyBatis中有两种占位符：**#{ }** 和 **${ }**，MyBatis对它们的处理方式是不同的：</p>
<ul>
<li>#{}是预编译处理：告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中。</li>
<li>${}是字符串替换：用于在SQL语句中插入一个不转义的字符串。MyBatis 不会修改或转义字符串。当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。用这种方式接受用户的输入，并将其用于语句中的参数是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>两种占位符的用法基本上是一致的，在Java代码中使用注解*@Param*，通过注解定指可用的参数及其参数名，例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是基本类型</span></span><br><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(<span class="meta">@Param(&quot;demoId&quot;)</span> <span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是对象</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">find</span><span class="params">(<span class="meta">@Param(&quot;demoQuery&quot;)</span> Query query)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后在xml配置文件中通过占位符传入参数，对于参数是基本数据类型获取方式如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from test where id = #&#123;demoId&#125;;</span><br><span class="line">select * from test where id = $&#123;demoId&#125;;</span><br></pre></td></tr></table></figure>

<p>对于参数是对象，需要显式指定需要传入的对象属性，例如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from test where id = #&#123;demoQuery.id&#125;;</span><br><span class="line">select * from test where id = $&#123;demoQuery.id&#125;;</span><br></pre></td></tr></table></figure>

<p>稍微要提一下的是，虽然**#{ }** 和 **${ }**均为通过参数名来获得对应的值，但使用上还是有细微差别的。</p>
<p>对于参数是基本数据类型，**${ }<strong>的变量名必须为@Param注解中指定的参数名，</strong>#{ }**中的变量名可以是@Param注解中指定的参数名或者方法中的参数名，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是基本类型</span></span><br><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(<span class="meta">@Param(&quot;demoId&quot;)</span> <span class="keyword">long</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- #&#123;&#125;中的变量名可以是@Param注解中指定的参数名或者方法中的参数名 --&gt;</span></span><br><span class="line">select * from test where id = #&#123;id&#125;;</span><br><span class="line">select * from test where id = #&#123;demoId&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- $&#123;&#125;的变量名必须为@Param注解中指定的参数名 --&gt;</span></span><br><span class="line">select * from test where id = $&#123;demoId&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="性能和安全"><a href="#性能和安全" class="headerlink" title="性能和安全"></a>性能和安全</h2><ul>
<li>性能方面：**${ }<strong>是字符串替换，</strong>#{ }<strong>是预编译的，而相同的预编译SQL是可以重复利用的，因此</strong>#{}**性能更高。</li>
<li>安全方面：由于**${ }<strong>是字符串替换，参数传入什么就使用的是什么，如果没有经过检查和转义的话会有SQL注入的风险，而预编译的</strong>#{ }**没有这方面的顾虑</li>
</ul>
<p>因此在实际开发中，能用**#{ }<strong>的就用</strong>#{ }**。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="MyBatis中SQL执行顺序"><a href="#MyBatis中SQL执行顺序" class="headerlink" title="MyBatis中SQL执行顺序"></a>MyBatis中SQL执行顺序</h2><ol>
<li><p>对SQL语句进行动态解析，主要包括：</p>
<ul>
<li>占位符的处理</li>
<li>动态SQL的处理</li>
<li>参数类型校验</li>
</ul>
</li>
<li><p>SQL预编译</p>
</li>
</ol>
<h2 id="SQL预编译"><a href="#SQL预编译" class="headerlink" title="SQL预编译"></a>SQL预编译</h2><p>MyBatis默认情况下，将对所有的 sql 进行预编译。</p>
<p>SQL预编译指的是数据库驱动在发送SQL 语句和参数给 DBMS 之前对 SQL语句进行编译，这样 DBMS 执行 SQL时，就不需要重新编译。</p>
<p>在Java中通过JDBC中的PreparedStatement实现预编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String selectPerson = <span class="string">&quot;SELECT * FROM PERSON WHERE ID=?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br></pre></td></tr></table></figure>

<p>预编译有两个好处：</p>
<ol>
<li>优化SQl的执行：预编译之后的SQL多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。</li>
<li>预编译语句对象可以重复利用：把一个SQL预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://segmentfault.com/a/1190000004617028">https://segmentfault.com/a/1190000004617028</a></p>
<p><a href="https://www.cnblogs.com/huanyou/p/7201480.html">https://www.cnblogs.com/huanyou/p/7201480.html</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis缓存机制</title>
    <url>/posts/201dbebe.html</url>
    <content><![CDATA[<p>MyBatis提供了强大的事务性查询缓存机制，用于提高查询性能！</p>
<span id="more"></span>



<p>MyBatis的缓存分为：本地缓存和二级缓存，另外还可以实现自己的缓存或者使用第三方的缓存机制。</p>
<h1 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h1><p>MyBatis默认开启本地缓存，且无法手动关闭。</p>
<p>本地缓存属于会话级别的（sqlsession），生命周期与sqlsession一致，只对同一个sqlsession有效，不同sqlsession之间不共享缓存，</p>
<p>任何的修改操作（insert、update、delete）都会导致缓存清除，也可以通过配置使得查询前清空缓存。</p>
<h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><p>二级缓存默认关闭，需要手动开启。</p>
<p>二级缓存属于全局级别的（sqlsessionfactory），能够跨会话访问，弥补本地缓存无法跨会话访问的缺陷，开启后缓存使用时是先访问二级缓存再访问一级缓存。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于MyBatis的缓存机制只是流于表面，还没有更多的深入了解，且实现自己的缓存或使用第三方缓存机制这些也没有涉略，因此该篇文章仅做记录用。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
        <category>框架</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark开发环境配置</title>
    <url>/posts/ec94ecc9.html</url>
    <content><![CDATA[<p>要开发Spark程序，当然少不了要配置开发环境，本文将会带领大家如何在Windows和Linux上搭建开发环境。</p>
<span id="more"></span>

<h1 id="Windows篇"><a href="#Windows篇" class="headerlink" title="Windows篇"></a>Windows篇</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在开始配置前，首先需要下载搭建开发环境所必须的文件：</p>
<ol>
<li><a href="http://spark.apache.org/downloads.html"><strong>Hadoop</strong></a></li>
<li><a href="https://hadoop.apache.org/releases.html"><strong>Spark</strong></a></li>
<li><a href="https://github.com/steveloughran/winutils/releases"><strong>winutils</strong></a></li>
</ol>
<p>上述列表中的文件下载完成后，Hadoop和Spark可解压至任意目录（读者自己决定即可）。</p>
<p>比较特别的是<strong>winutils</strong>，在Windows环境下要对Hadoop进行调试开发<em>必须</em>要添加winutils组件，即把winutils压缩包下的所有文件全部放到<strong>Hadoop的bin目录</strong>下。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置开发环境其实很简单，只需要分别为Hadoop和Spark配置对应的环境变量HADOOP_HOME和SPAEK_HOME即可。</p>
<h3 id="配置Hadoop"><a href="#配置Hadoop" class="headerlink" title="配置Hadoop"></a>配置Hadoop</h3><p>进入windows的环境变量配置，并新建变量：</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HADOOP_HOME</td>
<td align="left">你的hadoop的根目录路径</td>
</tr>
</tbody></table>
<h3 id="配置Spark"><a href="#配置Spark" class="headerlink" title="配置Spark"></a>配置Spark</h3><p>进入windows的环境变量配置，并新建变量：</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SPARK_HOME</td>
<td align="left">你的spark的根目录路径</td>
</tr>
</tbody></table>
<p>当然，如果需要在命令行中使用spark的命令，可以在path变量中加入spark的bin目录路径：</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">path</td>
<td align="left">%SPARK_HOME%\bin</td>
</tr>
</tbody></table>
<p>至此，Windows篇的Spark开发环境就配置完成了。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>spark的开发环境配置其实和Java的开发环境配置一样，唯一的区别是windowns下需要额外添加winutils的相关文件。</p>
<p>至于Linix部分，会在后续进行跟新。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
        <category>框架</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot之Gradle插件</title>
    <url>/posts/dcecce02.html</url>
    <content><![CDATA[<p>在Java生态中，常用Maven和Gradle来对项目进行生命周期的管理。在本篇文章中使用Gradle来对Spring Boot项目进行构建，并记录常用的插件：java、war、dependency-management。</p>
<span id="more"></span>

<h1 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h1><p>关于Gradle的介绍在此省略，想了解相关知识的读者请自行搜索。</p>
<h1 id="SpringBoot插件"><a href="#SpringBoot插件" class="headerlink" title="SpringBoot插件"></a>SpringBoot插件</h1><blockquote>
<p>Spring Boot的Gradle插件提供了Spring Boot在Gradle上的支持，允许打包可执行的Jar包、war归档文件、运行Spring Boot应用，以及使用<em>spring-boot-dependecies</em>提供的依赖管理。<strong>注意:使用Spring Boot的Gradle插件需要Gradle4.0或以上的版本</strong></p>
</blockquote>
<p>由官方译文可以知道，想要使用Gradle来方便管理Spring Boot项目，使用SpringBoot插件是一个极佳的选择。</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>在Gradle中想要使用SpringBoot插件，需要如下的4个步骤：</p>
<ol>
<li>配置下载插件的仓库地址：<a href="https://repo.spring.io/libs-snapshot">https://repo.spring.io/libs-snapshot</a></li>
<li>在依赖中引入要使用的插件，即SpringBoot的Gradle插件spring-boot-gradel-plugin</li>
<li>指定插件的版本，最好与项目使用的Spring Boot版本一致。</li>
<li>应用插件</li>
</ol>
<p>整个基本配置如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springbootVersion = <span class="string">&#x27;2.0.1.BUILD-SNAPSHOT&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://repo.spring.io/snapshot&#x27;</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://repo.spring.io/milestone&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springbootVersion&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">&#x27;org.springframework.boot&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里应用Java插件或者war插件</span></span><br><span class="line">apply plugin: <span class="string">&#x27;java&#x27;</span></span><br><span class="line">apply plugin: <span class="string">&#x27;io.spring.dependency-management&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过上述配置，就能在整个项目中使用SpringBoot插件了。同时为了方便后续spring boot的版本更改，在配置中加入了自定义的变量<em>springbootVersion</em>，用于指代spring boot的版本。</p>
<p>注：在Gradle的字符串中使用变量，需要在双引号中使用（在单引号中会无法识别），并且要以*${变量名}*这种形式进行引用。</p>
<p>在Spring Boot项目中，除了springboot插件外，还需要Java插件或War插件，以及dependency-management插件，才能达到构建项目所需的最少插件。</p>
<h2 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h2><p>要在不创建归档文件（jar、war）的情况下运行应用程序，需要使用bootRun任务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gradle bootRun</span><br></pre></td></tr></table></figure>

<h3 id="配置主类"><a href="#配置主类" class="headerlink" title="配置主类"></a>配置主类</h3><p>通过配置主类可以指定应用的运行入口。</p>
<p>默认情况下，bootRun任务会自动通过寻找在任务类路径下的目录中的带有*public static void main(String[])*方法的类配置为主类（main class）。</p>
<p>当然，可以通过bootRun任务的main属性显式地配置主类：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">bootRun &#123;</span><br><span class="line">  main = <span class="string">&#x27;com.example.ExampleApplication&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，可以使用Spring Boot DSL的mainClassName属性在项目范围内配置主类：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">springBoot &#123;</span><br><span class="line">  mainClassName =<span class="string">&#x27;com.example.ExampleApplication&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>当项目中应用io.spring.dependency-management插件时，Spring Boot的插件会自动从项目中正在使用的Spring Boot版本导入相应的spring-boot-dependencies bom。这为Maven用户提供了类似的依赖管理体验，可以像使用使用maven一样，自定义依赖的jar包版本、排除依赖等。</p>
<p>当然可以不使用io.spring.dependency-management插件，但是这会为项目的管理徒然增加难度。</p>
<h3 id="自定义版本号"><a href="#自定义版本号" class="headerlink" title="自定义版本号"></a>自定义版本号</h3><p>通过使用依赖管理插件，可以使用属性来控制依赖关系的版本，参考<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-dependencies/pom.xml">bom</a>，例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ext[<span class="string">&#x27;slf4j.version&#x27;</span>] = <span class="string">&#x27;1.7.20&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot的每个发布版本都是针对特定的第三方依赖来进行设计和测试。覆盖版本可能会导致兼容性问题，应该要小心处理。</p>
</blockquote>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>单独的使用SpringBoot插件对项目几乎没有改变，但是当使用了某些插件时，SpringBoot插件会检测出该插件并对项目配置做出相应的改变。以下列出几个常用的插件：</p>
<h3 id="Java插件"><a href="#Java插件" class="headerlink" title="Java插件"></a>Java插件</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;java&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当项目中使用了Java插件，Gradle会做出以下改变：</p>
<ol>
<li>创建一个名为bootJar的BootJar任务：为项目创建一个可执行的jar。该jar将包含项目目录结构中main文件集中运行时类路径中的所有内容;类被放置在BOOT-INF / classes中，而jar被放置在BOOT-INF / lib中</li>
<li>将assemble任务配置为依赖于bootJar任务</li>
<li>禁用jar任务</li>
<li>创建了一个名为bootRun的BootRun任务，用于运行该项目</li>
<li>创建一个名为bootArchives的配置，其中包含由bootJar任务生成的组件</li>
<li>配置任何没有配置编码的JavaCompile任务以使用UTF-8编码</li>
<li>配置任何JavaCompile任务以使用-parameters编译器参数</li>
</ol>
<h3 id="War插件"><a href="#War插件" class="headerlink" title="War插件"></a>War插件</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;war&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当项目中使用了war插件，Gradle会做出以下改变：</p>
<ol>
<li>创建一个名为bootWar的BootWar任务，该任务将为该项目创建一个可执行的war。除了标准打包之外，providedRuntime配置中的所有内容都将打包在WEB-INF/lib-provided的文件夹中</li>
<li>将assemble任务配置为依赖于bootWar任务</li>
<li>禁用war任务</li>
<li>配置bootArchives的配置以包含由bootWar任务生成的组件</li>
</ol>
<p>注意：使用了war插件就不需要再使用Java插件了。</p>
<h3 id="dependency-management插件"><a href="#dependency-management插件" class="headerlink" title="dependency-management插件"></a>dependency-management插件</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;io.spring.dependency-management&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当项目应用<em>io.spring.dependency-management</em>插件时，SpringBoot插件将会自动从项目中正在使用的Spring Boot版本中导入spring-boot-dependencies bom。为Maven用户提供了类似的依赖管理体验。</p>
<p>注意：当使用了该插件时，可以在引用spring-boot-starter-**项目时省略相应的版本号，默认使用与项目一致的版本号。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>SpringBoot插件可以创建可执行的归档文件（jar、war），其中包含了一个应用所需的全部依赖，并且能够使用<em>java -jar</em>命令来运行。</p>
<h3 id="打包可执行的jar"><a href="#打包可执行的jar" class="headerlink" title="打包可执行的jar"></a>打包可执行的jar</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gradle bootJar</span><br></pre></td></tr></table></figure>

<p>可执行jar可以使用bootJar任务来构建。该任务在应用java插件时自动创建，并且是BootJar的一个实例。assemble任务自动配置为依赖于bootJar任务，因此运行assemble（或built）也将运行bootJar任务</p>
<h3 id="打包可执行的war"><a href="#打包可执行的war" class="headerlink" title="打包可执行的war"></a>打包可执行的war</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gradle bootWar</span><br></pre></td></tr></table></figure>

<p>可执行war可以使用bootWar任务来构建。该任务在应用war插件时自动创建，并且是BootWar的一个实例。assemble任务自动配置为依赖于bootWar任务，因此运行assemble（或built）也将运行bootWar任务</p>
<p>一个war文件可以被打包，以便它可以使用java -jar执行并被部署到一个外部容器。为此，应该将嵌入式servlet容器依赖项添加到providedRuntime配置中，列如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">  providedRuntime <span class="string">&#x27;org.springframework.boot:spring-boot-starter-tomcat&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可以确保它们被封装在war文件的WEB-INF/lib提供的目录中，在哪里它们不会与外部容器的类冲突</p>
<h3 id="同时打包可执行的和常规的归档文件"><a href="#同时打包可执行的和常规的归档文件" class="headerlink" title="同时打包可执行的和常规的归档文件"></a>同时打包可执行的和常规的归档文件</h3><p>默认情况下，当配置bootJar或bootWar任务时，jar或war任务被禁用。通过启用jar或war任务，可以将项目配置为同时构建可执行归档文件和常规归档文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">  enabled &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为避免可执行文件和常规归档被写入同一位置，应将其中一个或另一个配置为使用不同的位置。其中一种方式是通过配置分类器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bootJar &#123;</span><br><span class="line">  classifier &#x3D; &#39;boot&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排除Devtools"><a href="#排除Devtools" class="headerlink" title="排除Devtools"></a>排除Devtools</h3><p>默认情况下，Spring Boot的Devtools模块org.springframework.boot：spring-boot-devtools将被排除在可执行jar或war之外。如果您想在您的归档文件中包含Devtools，可以将将excludeDevtools属性设置为false，例子如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">bootWar &#123;</span><br><span class="line">  excludeDevtools = <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置需要解包的库"><a href="#配置需要解包的库" class="headerlink" title="配置需要解包的库"></a>配置需要解包的库</h3><p>当嵌套在可执行归档文件中时，大多数库可以直接使用，但某些库可能有问题。要处理任何有问题的库，可配置为在运行可执行归档文件时将特定的嵌套jar包解压到临时文件夹，可以将库标识为需要使用与源代码文件的绝对路径相匹配的Ant样式模式进行解包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bootJar &#123;</span><br><span class="line">  requiresUnpack &#39;**&#x2F;jruby-complete-*.jar&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更多的控制，也可以使用闭合。闭包传递一个FileTreeElement，并返回一个布尔值，指示是否需要拆箱</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文大部分内容都摘录自官方文档，但通过阅读文档依然收获良多，并记录下自己常用或者可能会用到的知识点。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.BUILD-SNAPSHOT/gradle-plugin/reference/html/">Spring Boot的Gradle插件</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
        <category>框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot之devtools模块</title>
    <url>/posts/f815ac63.html</url>
    <content><![CDATA[<p>为了方便项目的开发，spring boot提供了一个相应的开发者工具：spring-boot-devtools模块，通过使用该模块就能获得相应的开发时特性。本文章讲述的就是如何配置相关的特性。</p>
<span id="more"></span>

<p>spring-boot-devtools模块，提供了一系列开发时特性，包括：热部署、livereload等。合理的使用这些特性能有助于项目的开发。</p>
<h1 id="引入devtools模块"><a href="#引入devtools模块" class="headerlink" title="引入devtools模块"></a>引入devtools模块</h1><p>在项目中加入devtools模块很简单，只要在构建工具中引入相应的包即可。</p>
<p>值得一提的是：在Maven中将devtools依赖标记为optional，在Gradle中使用compileOnly来引用devtools依赖，是一个很好的习惯，可以有效的阻止devtools模块传递并应用到引用了该项目的项目。</p>
<h2 id="Gradle配置"><a href="#Gradle配置" class="headerlink" title="Gradle配置"></a>Gradle配置</h2><p>gradle的配置如下所示，值得注意的是下面并没有加入版本号，这是因为使用了io.spring.dependency-managent插件，从而省略了版本号。如果没有使用该插件就需要明确的标识出版本号。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&#x27;org.springframework.boot:spring-boot-devtools&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p>maven的配置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><p>在运行一个完整打包的项目时devtools会被<strong>自动禁用</strong>。</p>
<p>默认情况下，打包好的jar、war是不包含devtools模块的，如果需要在已打包好的jar、war使用相关的开发特性，就需要在构建工具中，显式地配置excledeDevtools属性，让构建工具在打包时不要排除devtools模块。</p>
<h1 id="开发时特性"><a href="#开发时特性" class="headerlink" title="开发时特性"></a>开发时特性</h1><h2 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h2><p>当类路径上的文件发生变化时将会触发应用程序的自动重启，而无需自己手动重启项目，但是会自动忽略项目名为spring-boot、spring-boot-devtools、 spring-boot-autoconfigure、spring-boot-actuator和 spring-boot-starter的项目，即以上项目的改变不会触发重启。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Spring Boot提供的重启技术通过使用两个类加载器来工作，一个基类加载器用于加载不会改变的资源（例：第三方jar包），一个重启类加载器用于加载正在开发的类，当重启时仅重新创建重启类加载器的实例，从而实现更快的重启速度。</p>
<h3 id="资源钩子shutdown-hook"><a href="#资源钩子shutdown-hook" class="headerlink" title="资源钩子shutdown hook"></a>资源钩子shutdown hook</h3><p>devtools是依靠应用程序上下文的资源钩子（shutdown hook）在重启期间关闭它，如果禁用了资源钩子将会使得devtools无法正常工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplication.setRegisterShutdownHook(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<h3 id="排除资源"><a href="#排除资源" class="headerlink" title="排除资源"></a>排除资源</h3><p>某些资源的改变是无需触发重启的。默认情况下，改变的资源在以下路径中：/META-INF/maven, /META-INF/resources, /resources, /static, /public, /templates都不会触发重启而是会触发实时重新加载。当然我们也可以自定义排除的资源，只要修改<em>spring.devtools.restart.exclude</em>属性，例子：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.restart.exclude</span>=<span class="string">static/**,public/**</span></span><br></pre></td></tr></table></figure>

<p>但是以上写法会覆盖默认值，所以如果在不想覆盖默认值的情况下加入自定义的排除资源，需要使用<em>spring.devtools.restart.additional-exclude</em>属性，例子：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.restart.additional-exclude</span>=<span class="string">static/**,public/**</span></span><br></pre></td></tr></table></figure>

<h3 id="监控其它路径"><a href="#监控其它路径" class="headerlink" title="监控其它路径"></a>监控其它路径</h3><p>默认的是只有类路径下的文件发生了改变才会触发重启，如果想要不在类路径下的资源发生改变后触发重启，需要使用<em>spring.devtools.restart.additional-paths</em>属性来配置额外的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.devtools.restart.additional-paths &#x3D; other-path&#x2F;**</span><br></pre></td></tr></table></figure>

<h3 id="关闭自动重启"><a href="#关闭自动重启" class="headerlink" title="关闭自动重启"></a>关闭自动重启</h3><p>如果不需要使用自动重启，可以通过禁用spring.devtools.restart.enabled属性来关闭该特性（注：重启类加载器依然会被初始化，但是不会监控文件的改变）。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.restart.enabled</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>如果想要彻底关闭devtools对于重启的支持，需要在调用SpringApplication.run()前，禁用<em>spring.devtools.restart.enabled</em>属性，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.setProperty(<span class="string">&quot;spring.devtools.restart.enabled&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">  SpringApplication.run(MyApp.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h2><p>spring-boot-devtools包含了一个嵌入式的LiveReload服务器，允许当资源发生改变时实时刷新浏览器。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.livereload.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>默认的，该特性是打开了的。如果想停用该特性，则设置为：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.livereload.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>spring-boot-devtools模块的开发时特性并没有完整的出现在文章中，比如说远程支持，更换类加载器等，仅仅选取了平时可能会用到的特性进行记录。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools">Spring Boot官方文档 Developer Tools</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
        <category>框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>注解@Autowired和@Resource区别</title>
    <url>/posts/f6f32af4.html</url>
    <content><![CDATA[<p>Spring提供了注解@Autowired用于依赖注入，同时也支持使用Java本身提供的注解@Resource用于依赖注入，这两个注解有什么异同呢？</p>
<span id="more"></span>



<h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><p><em>@Autowired</em>和*@Resource*都是用来装配bean的，都可以注解在字段上和setter方法上</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>归属上：*@Autowired<em>是属于Spring的，</em>@Resource*是属于Java的。</li>
<li>装配方式：<ul>
<li><em>@Autowired</em>默认按照类型装配（默认情况下依赖对象必须存在，如果允许null，可以设置required属性为false），如果需要按照名称匹配需要结合@Qualifier使用。要注意只能有一个实现类否则存在多个候选对象会报错。</li>
<li>@Resource默认按照名称装配，名称通过name属性指定（不指定时取字段名或者setter方法上的属性名），当根据名称找不到时会按照类型进行装配，如果name一旦指定就只会按照名称进行装配。使用@Resource能较少代码耦合。</li>
</ul>
</li>
</ul>
<p>注：速度上，这两种方式都是直接指定name是最快的。</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>编程语言</category>
        <category>Java</category>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
